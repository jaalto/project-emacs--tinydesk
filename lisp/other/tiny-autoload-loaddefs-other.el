;;; tiny-autoload-loaddefs-other.el -- loaddef definitions of program files
;;  Generate date: 2002-01-02
;;  This file is automatically generated. Do not Change.

(provide 'tiny-autoload-loaddefs-other)


;;;### (autoloads (set-modified-alist modify-alist remove-alist set-alist
;;;;;;  del-alist put-alist) "alist" "alist.el" (14456 65500))
;;; Generated autoloads from alist.el

(autoload (quote put-alist) "alist" "\
Modify ALIST to set VALUE to ITEM.
If there is a pair whose car is ITEM, replace its cdr by VALUE.
If there is not such pair, create new pair (ITEM . VALUE) and
return new alist whose car is the new pair and cdr is ALIST.
[tomo's ELIS like function]" nil nil)

(autoload (quote del-alist) "alist" "\
If there is a pair whose key is ITEM, delete it from ALIST.
[tomo's ELIS emulating function]" nil nil)

(autoload (quote set-alist) "alist" "\
Modify a alist indicated by SYMBOL to set VALUE to ITEM." nil nil)

(autoload (quote remove-alist) "alist" "\
Remove ITEM from the alist indicated by SYMBOL." nil nil)

(autoload (quote modify-alist) "alist" "\
Modify alist DEFAULT into alist MODIFIER." nil nil)

(autoload (quote set-modified-alist) "alist" "\
Modify a value of a symbol SYM into alist MODIFIER.
The symbol SYM should be alist. If it is not bound,
its value regard as nil." nil nil)

;;;***

;;;### (autoloads (c-comment-edit c-comment-edit-at-point) "c-comment-edit2"
;;;;;;  "c-comment-edit2.el" (15378 27670))
;;; Generated autoloads from c-comment-edit2.el

(defvar c-comment-leader " *" "\
*Leader used when rebuilding edited C comments.  The value of this variable
should be a two-character string.  Values of \"  \", \" *\" and \"**\"
produce the comment styles:
        /*	/*	/*
          ...	 * ...	** ...
          ...	 * ...	** ...
        */	 */	*/
respectively.")

(autoload (quote c-comment-edit-at-point) "c-comment-edit2" "\
Edit C comment at point.
If point is inside of a comment, the comment is edited.  Otherwise, a new
comment is created at point.
" t nil)

(autoload (quote c-comment-edit) "c-comment-edit2" "\
Edit multi-line C comments.
This command allows the easy editing of a multi-line C comment like this:
   /*
    * ...
    * ...
    */
The comment may be indented or flush with the left margin.

If point is within a comment, that comment is used.  Otherwise the
comment to be edited is found by searching forward from point.

With one \\[universal-argument] searching starts after moving back one
  paragraph.
With two \\[universal-argument]'s searching starts at the beginning of the
  current or proceeding C function.
With three \\[universal-argument]'s searching starts at the beginning of the
  current page.
With four \\[universal-argument]'s searching starts at the beginning of the
  current buffer (clipping restrictions apply).

Once located, the comment is copied into a temporary buffer, the comment
leaders and delimiters are stripped away and the resulting buffer is
selected for editing.  The major mode of this buffer is controlled by
the variable `c-comment-edit-mode'.

Use \\[c-comment-edit-end] when you have finished editing the comment.  The
comment will be inserted into the original buffer with the appropriate
delimiters and indention, replacing the old version of the comment.  If
you don't want your edited version of the comment to replace the
original, use \\[c-comment-edit-abort]." t nil)

;;;***

;;;### (autoloads (cm-install-default cm-minibuffer-completion-help
;;;;;;  cm-load-hook) "complete-menu" "complete-menu.el" (15011 59622))
;;; Generated autoloads from complete-menu.el

(defvar cm-load-hook (quote (cm-install-default)) "\
*Hook run when file has been loaded.")

(autoload (quote cm-minibuffer-completion-help) "complete-menu" "\
List completions in a menu and copy selction into minibuffer" t nil)

(autoload (quote cm-install-default) "complete-menu" "\
Install the X-menuing feature. With ARG, remove X-menuing. VERB.
Note: installation is only possible in X envinronment." t nil)

;;;***

;;;### (autoloads (dired-sort-default-keys dired-resort dired-sort-by-size
;;;;;;  dired-sort-by-field dired-sort-by-type dired-sort-by-date)
;;;;;;  "dired-sort" "dired-sort.el" (15381 10582))
;;; Generated autoloads from dired-sort.el

(autoload (quote dired-sort-by-date) "dired-sort" "\
In dired, sort the lines by date, newest first.
With ARG, sorts oldest first." t nil)

(autoload (quote dired-sort-by-type) "dired-sort" "\
Sort by type, ARG means reverse." t nil)

(autoload (quote dired-sort-by-field) "dired-sort" "\
In dired, sort the lines by FIELD (defaults to the mode field)." t nil)

(autoload (quote dired-sort-by-size) "dired-sort" "\
In dired, sort the lines by file size, largest first.
With ARG, sorts in the reverse order (smallest first).
All directories are grouped together at the head of the buffer,
and other file types are also grouped." t nil)

(autoload (quote dired-resort) "dired-sort" "\
In dired, change the sorting of lines. Prompt for the KIND of sorting.
Non-interactively, takes a sort-kind, and an optional argument for
the associated function. To get a list of such arguments interactively,
call read-dired-resort-args. ARGS are passed to sort." t nil)

(autoload (quote dired-sort-default-keys) "dired-sort" "\
Define default bindings to dired map." t nil)

(add-hook (quote dired-mode-hook) (quote dired-sort-default-keys) (quote end))

;;;***

;;;### (autoloads (with-expect) "expect" "expect.el" (14954 14938))
;;; Generated autoloads from expect.el

(autoload (quote with-expect) "expect" "\
Set things up for communication with PROGRAM.
FORMS will be evaluated in the normal manner.  To talk to the process,
use `expect' and `expect-send'.  See the manual for full documentation.
This macro returns nil.

If PROGRAM is a string, start that program.  If PROGRAM is a list, use
the first element of that list as the program and the remainder as the
parameters.  If PROGRAM is a process, talk to that process.

PROGRAM will be started up in a new, fresh temporary buffer.  The
buffer will be killed upon completion.  If PROGRAM is a process,
a new buffer won't be created, and the buffer won't be killed upon
completion." nil (quote macro))

;;;***

;;;### (autoloads (fnexpand-complete) "fnexpand" "fnexpand.el" (15378
;;;;;;  27670))
;;; Generated autoloads from fnexpand.el

(defvar fnexpand-executable-enable nil "\
*if non-nil, then try to expand executable files too.
Beware, this may be time consuming.")

(autoload (quote fnexpand-complete) "fnexpand" "\
Expand the file name, env var or command near point" t nil)

;;;***

;;;### (autoloads (folding-mode turn-on-folding-mode turn-off-folding-mode
;;;;;;  folding-mode-add-find-file-hook folding-keep-hooked folding-install-hooks
;;;;;;  folding-uninstall-hooks folding-mode-hook-no-regexp folding-mode-string
;;;;;;  folding-inside-mode-name folding-default-mouse-keys-function
;;;;;;  folding-default-keys-function) "folding" "folding.el" (15407
;;;;;;  51274))
;;; Generated autoloads from folding.el

(defvar folding-mode nil "\
When Non nil, Folding mode is active in the current buffer.")

(defvar folding-default-keys-function (quote folding-bind-default-keys) "\
*Function or list of functions used to define keys for Folding mode.
Possible values are:
  folding-bind-default-key
        The standard keymap.

  `folding-bind-backward-compatible-keys'
        Keys used by older versions of Folding mode. This function
        does not conform to Emacs 19.29 style conversions concerning
        key bindings. The prefix key is C - c

  `folding-bind-outline-compatible-keys'
        Define keys compatible with Outline mode.

  `folding-bind-foldout-compatible-keys'
        Define some extra keys compatible with Foldout.

All except `folding-bind-backward-compatible-keys' used the value of
the variable `folding-mode-prefix-key' as prefix the key.
The default is C - c @")

(defvar folding-default-mouse-keys-function (quote folding-bind-default-mouse) "\
*Function to bind default mouse keys to `folding-mode-map'.")

(defvar folding-inside-mode-name "Fld" "\
*Mode line addition to show inside levels of 'fold' .")

(defvar folding-mode-string "Fld" "\
*The minor mode string displayed when mode is on.")

(defvar folding-mode-hook-no-regexp "RMAIL" "\
*Regexp which disable automatic folding mode turn on for certain files.")

(defvar folding-mode-marks-alist nil "\
List of (major-mode . fold mark) default combinations to use.
When Folding mode is started, the major mode is checked, and if there
are fold marks for that major mode stored in `folding-mode-marks-alist',
those marks are used by default. If none are found, the default values
of \"{{{ \" and \"}}}\" are used.

Use function  `folding-add-to-marks-list' to add more fold marks. The function
also explains the alist use in details.

Use function `folding-set-local-variables' is you change the current mode's
folding marks during the session.")

(autoload (quote folding-uninstall-hooks) "folding" "\
Remove hooks set by folding." t nil)

(autoload (quote folding-install-hooks) "folding" "\
Install folding hooks." t nil)

(autoload (quote folding-keep-hooked) "folding" "\
Make sure hooks are in their places." nil nil)

(autoload (quote folding-mode-add-find-file-hook) "folding" "\
Append `folding-mode-find-file-hook' to the list `find-file-hooks'.

This has the effect that afterwards, when a folded file is visited, if
appropriate Emacs local variable entries are recognized at the end of
the file, Folding mode is started automatically.

If `inhibit-local-variables' is non-nil, this will not happen regardless
of the setting of `find-file-hooks'.

To declare a file to be folded, put `folded-file: t' in the file's
local variables. eg., at the end of a C source file, put:

/*
Local variables:
folded-file: t
*/

The local variables can be inside a fold." t nil)

(autoload (quote turn-off-folding-mode) "folding" "\
Turn on folding." nil nil)

(autoload (quote turn-on-folding-mode) "folding" "\
Turn on folding." nil nil)

(autoload (quote folding-mode) "folding" "\
A folding-editor-like minor mode. ARG INTER.

These are the basic commands that Folding mode provides:

\\{folding-mode-map}

Keys starting with `folding-mode-prefix-key'

\\{folding-mode-prefix-map}

     folding-convert-buffer-for-printing:
     `\\[folding-convert-buffer-for-printing]'
     Makes a ready-to-print, formatted, unfolded copy in another buffer.

     Read the documentation for the above functions for more information.

Overview

    Folds are a way of hierarchically organizing the text in a file, so
    that the text can be viewed and edited at different levels. It is
    similar to Outline mode in that parts of the text can be hidden from
    view. A fold is a region of text, surrounded by special \"fold marks\",
    which act like brackets, grouping the text. Fold mark pairs can be
    nested, and they can have titles. When a fold is folded, the text is
    hidden from view, except for the first line, which acts like a title
    for the fold.

    Folding mode is a minor mode, designed to cooperate with many other
    major modes, so that many types of text can be folded while they are
    being edited (eg., plain text, program source code, Texinfo, etc.).

Folding-mode function

    If Folding mode is not called interactively (`(interactive-p)' is nil),
    and it is called with two or less arguments, all of which are nil, then
    the point will not be altered if `folding-folding-on-startup' is set
    and `folding-whole-buffer' is called. This is generally not a good
    thing, as it can leave the point inside a hidden region of a fold, but
    it is required if the local variables set \"mode: folding\" when the
    file is first read (see `hack-local-variables').

    Not that you should ever want to, but to call Folding mode from a
    program with the default behavior (toggling the mode), call it with
    something like `(folding-mode nil t)'.

Fold marks

    For most types of folded file, lines representing folds have \"{{{\"
    near the beginning. To enter a fold, move the point to the folded line
    and type `\\[folding-shift-in]'. You should no longer be able to see
    the rest of the file, just the contents of the fold, which you couldn't
    see before. You can use `\\[folding-shift-out]' to leave a fold, and
    you can enter and exit folds to move around the structure of the file.

    All of the text is present in a folded file all of the time. It is just
    hidden. Folded text shows up as a line (the top fold mark) with \"...\"
    at the end. If you are in a fold, the mode line displays \"inside n
    folds Narrow\", and because the buffer is narrowed you can't see outside
    of the current fold's text.

    By arranging sections of a large file in folds, and maybe subsections
    in sub-folds, you can move around a file quickly and easily, and only
    have to scroll through a couple of pages at a time. If you pick the
    titles for the folds carefully, they can be a useful form of
    documentation, and make moving though the file a lot easier. In
    general, searching through a folded file for a particular item is much
    easier than without folds.

Managing folds

    To make a new fold, set the mark at one end of the text you want in the
    new fold, and move the point to the other end. Then type
    `\\[folding-fold-region]'. The text you selected will be made into a
    fold, and the fold will be entered. If you just want a new, empty fold,
    set the mark where you want the fold, and then create a new fold there
    without moving the point. Don't worry if the point is in the middle of
    a line of text, `folding-fold-region' will not break text in the middle
    of a line. After making a fold, the fold is entered and the point is
    positioned ready to enter a title for the fold. Do not delete the fold
    marks, which are usually something like \"{{{\" and \"}}}\". There may
    also be a bit of fold mark which goes after the fold title.

    If the fold markers get messed up, or you just want to see the whole
    unfolded file, use `\\[folding-open-buffer]' to unfolded the whole
    file, so you can see all the text and all the marks. This is useful for
    checking/correcting unbalanced fold markers, and for searching for
    things. Use `\\[folding-whole-file]' to fold the buffer again.

    `folding-shift-out' will attempt to tidy the current fold just before
    exiting it. It will remove any extra blank lines at the top and bottom,
    (outside the fold marks). It will then ensure that fold marks exists,
    and if they are not, will add them (after asking). Finally, the number
    of blank lines between the fold marks and the contents of the fold is
    set to 1 (by default).

Folding package customisations

    If the fold marks are not set on entry to Folding mode, they are set to
    a default for current major mode, as defined by
    `folding-mode-marks-alist' or to \"{{{ \" and \"}}}\" if none are
    specified.

    To bind different commands to keys in Folding mode, set the bindings in
    the keymap `folding-mode-map'.

    The hooks `folding-mode-hook' and `<major-mode-name>-folding-hook' are
    called before folding the buffer and applying the key bindings in
    `folding-mode-map'. This is a good hook to set extra or different key
    bindings in `folding-mode-map'. Note that key bindings in
    `folding-mode-map' are only examined just after calling these hooks;
    new bindings in those maps only take effect when Folding mode is being
    started. The hook `folding-load-hook' is called when Folding mode is
    loaded into Emacs.

Mouse behavior

    If you want folding to detect point of actual mouse click, please see
    variable `folding-mouse-yank-at-p'.

    To customise the mouse actions, look at `folding-behave-table'." t nil)

;;;***
