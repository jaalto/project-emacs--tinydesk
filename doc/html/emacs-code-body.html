<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN"
  "http://www.w3.org/TR/REC-html40/frameset.dtd">
<HTML>
<!--
        See RCS ident(1) why these funny tags
        $Document:  $
        $Contact:   $
        Note: the LINK tags are used by advanced browsers.
-->
<HEAD>
<TITLE>
Emacs Lisp coding thoughts
</TITLE>



<!--    ......................................................................
    META TAGS (FOR SEARCH ENGINES)
    ......................................................................
-->

  <META HTTP-EQUIV="keywords"
	CONTENT="Emacs, Emacs Lisp, Documentation">

  <META HTTP-EQUIV="description"
	CONTENT="">


  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=utf-8">

  <META HTTP-EQUIV="Expires" CONTENT="Mon, 18 Oct 2004 09:06:24 GMT">



  <META NAME="Generator"
	CONTENT="2004-08-19 12:06 Perl program t2html.pl v2004.0428 http://perl-text2html.sourceforge.net/">



<!--    ......................................................................
    BUTTON DEFINITION START
    ......................................................................
-->


    <STYLE TYPE="text/css">


        /*

            ///////////////////////////////////////////////////////////
               NOTE    NOTE    NOTE    NOTE    NOTE    NOTE    NOTE

            This is the default CSS 2.0 generated by the program,
            please see "t2html.pl --help" for option --script-file
            to import your own CSS and Java definitions into the page.

            XHTML note: at page http://www.w3.org/TR/xhtml1/#guidelines
            It is recommended that CSS2 with XHTML use lowercase
            element and attribute names

            This default CSS2 has been validated according to
            http://jigsaw.w3.org/css-validator/validator-uri.html.en

            To design colors, visit:
            http://www.btexact.com/people/rigdence/colours/

               NOTE    NOTE    NOTE    NOTE    NOTE    NOTE    NOTE
            ///////////////////////////////////////////////////////////

            Comments on the CSS tags:

            -   block-width: "thin" (Netscape ok, MSIE nok)

            NETSCAPE 4.05

            -  In general does not render CSS very well. Eg
               font size changes does not show up in screen.
            -  :hover property is not recognised

            NETSCAPE 4.75 as of 2000-10-01

            -  Shows garbage for stylesheet section that marked CITATION.
               (IE has no trouble to show it)

            MSIE 4.0+

            - Renders CSS very well.

            Media types

            - Netscape does not transfer the CSS element definitions to
              the "print" media as it should. They only affect Browser
              or media "screen"
            - That is why you really have to say EM STRONG ... /STRONG EM
              to get that kind of text seen in printer too. You cannot
              just define P.column7 { ... }

            The @media CSS definition is not supported by Netscape 4.05
            I do not know if MSIE 4.0 supports it.

            So doing this would cause CSS to be ignored completely
            (never mind that CSS says the default CSS applies to "visual",
            which means both print and scree types.)

                @media print, screen {  P.code {..}  }

            To work around that, we separate the definitions with

                P.code { .. }               // For screen

                @media print { P.code      // for printer
                {
                    ..
                }}

            And wish that some newer browser will render it right.

        */

        /*   ///////////////////////////////////////////////// HEADINGS */

        h1.default
        {
            font-family: bold x-large Arial,helvetica,Sans-serif;
            padding-top: 10pt;
        }


        h2.default
        {
            font-family: bold large Arial,Helvetica,Sans-serif;
        }

        h3.default
        {
            font-family: bold medium Arial,Helvetica,Sans-serif;
        }

        h4.default
        {
            font-family: medium Arial,Helvetica,Sans-serif;
        }


        /*   ////////////////////////// Make pointing AHREF more visual */

        body
        {
            font-family: "Times New Roman", serif;
            

            /*
                More readable font, Like Arial in MS Word
                The background color is grey

                font-family: "verdana", sans-serif;
                background-color: #dddddd;
                foreground-color: #000000;

                Traditional "Book" and newspaper font
                font-family: "Times New Roman", serif;
            */
        }

        a:link
        {
            font-style: italic;
        }

        /*   A name=... link references */

        a.name
        {
            font-style: normal;
        }

        a:hover
        {
            color:           purple;
            background:      #AFB;
            text-decoration: none;
        }

            /* cancel above italic in TOC and Navigation buttons */

        a.btn:link
        {
            font-style: normal;
        }

            /* each link in TOC */


        a.toc
        {
            font-family: verdana, sans-serif;
            font-style: normal;
        }

        a.toc:link
        {
            font-style: normal;
        }

            /* [toc] heading button which appears in non-frame html */

        a.btn-toc:link
        {
            font-style: normal;
            font-family: verdana, sans-serif;
            /* font-size:  0.7em; */
        }

        /*  //////////////////////////////////// Format the code sections  */

        /*  MSIE ok, Netscape nok: Indent text to same level to the right  */

        blockquote
        {
            margin-right: 0;
        }

        @media print   { BLOCKQUOTE
        {
            margin-right: 0;
        }}

        samp.code
        {
            color: Navy;
        }

        pre
        {
            font-family:   "Courier New", monospace;
            font-size:     0.8em;
        }

        pre.code
        {
            color: Navy;
        }

        p.code, p.code1, p.code2
        {
            /*
               margin-top:     0.4em;
               margin-bottom:  0.4em;
               line-height:    0.9em;
            */

            font-family:    "Courier New", monospace;
            font-size:      0.8em;

            color:          Navy;
        }

        /* //////////////////////// tables /////////////////////////// */

        table.basic
        {
                font-family:    "Courier New", monospace;
                color: Navy;
        }


        table.dashed
        {

                /* font-family: sans-serif; /*
                /* background:  #F7DE9C; */

                color: Navy;

                border-top:     1px #999999 solid;
                border-left:    1px #999999 solid;
                border-right:   1px #666666 solid;
                border-bottom:  1px #666666 solid;
                border-width:   94%;
                border-style: dashed; /* dotted */


                /* line-height: 105%; */
        }


        table.solid
        {
                font-family:    "Courier New", monospace;
                /* afont-size:      0.8em; */

                color:          Navy;

                /* font-family: sans-serif; /*
                /* background:  #F7DE9C; */

                border-top:     1px #CCCCCC solid;
                border-left:    1px #CCCCCC solid; /* 999999 */
                border-right:   1px #666666 solid;
                border-bottom:  1px #666666 solid; /* dark grey */
                /* line-height: 105%; */
        }


        /* Make 3D styled layout by thickening the boton + right. */

        table.shade-3d
        {
                font-family:    "Courier New", monospace;
                font-size:      0.8em;

                color:          #999999; /* Navy; */

                /* font-family: sans-serif; /*
                /* background:  #F7DE9C; */

                /* border-top:  1px #999999 solid; */
                /* border-left: 1px #999999 solid; */
                border-right:   4px #666666 solid;
                border-bottom:  3px #666666 solid;
                /* line-height: 105%; */
        }


        .shade-3d-attrib
        {
            /*
                F9EDCC          Light Orange
                FAEFD2          Even lighter Orange

                #FFFFCC         Light yellow, lime

            */

            background: #FFFFCC;
        }


        table.shade-normal
        {
                font-family:    "Courier New", monospace;
                /* font-size:      0.9em; */
                color:          Navy;
        }

        .shade-normal-attrib
        {
            /*  grey: EAEAEA, F0F0F0 FFFFCC
                lime: F7F7DE CCFFCC
                pinkish: E6F1FD D8E9FB C6DEFA FFEEFF (light ... darker)
            */
            background: #EFEFEF;
        }


        table.shade-normal2
        {
                font-family:    "Courier New", monospace;
        }

        .shade-normal2-attrib
        {
            background: #E0E0F0;
        }


        table.shade-note
        {
            /* nothing special */
        }


        .shade-note-attrib
        {
            /*  darker is #E0E0F0; */
            /* background: #E5ECF3; */
            background: #E5ECF3;
            font-family: Georgia, Palatino, Verdana, Arial, Helvetica;
            font-size: 0.8em;
        }

        /* ..................................... colors ................. */

        .color-white
        {
            color: Navy;
            background: #FFFFFF;
        }

        .color-fg-navy
        {
            color: navy;
        }

        .color-fg-blue
        {
            color: blue;
        }

        .color-fg-teal
        {
            color: teal;
        }

        /*   Nice combination: teal-dark, beige2 and  beige-dark */

        .color-teal-dark
        {
            color: #96EFF2;
        }

        .color-beige
        {
            color: Navy;
            background: #F7F7DE;
        }

        .color-beige2
        {
            color: Navy;
            background: #FAFACA;
        }

        .color-beige-dark
        {
            color: Navy;
            background: #CFEFBD;
        }


        .color-pink-dark
        {
            background: #E6F1FD;
        }

        .color-pink-medium
        {
            background: #D8E9FB;
        }

        .color-pink
        {
            /*  grey: EAEAEA, F0F0F0 FFFFCC
                lime: F7F7DE CCFFCC
                pinkish: E6F1FD D8E9FB C6DEFA FFEEFF (light ... darker)
            */
            background: #C6DEFA;
        }

        .color-pink-light
        {
            background: #FFEEFF;
        }


        /* ////////////////////////////////////////////// Format columns */

        p.column3
        {
            color: Green;
        }

        p.column5
        {
            color: #87C0FF;   /* shaded casual blue */
        }

        p.column6
        {
            /* #809F69 is Forest green
               But web safe colors are:
               Lighter  ForestGreen: 66CC00
               ForestGreen: #999966 669900 339900 669966

            color: #669900;
            font-family: "Goudy Old Style"
            */
            margin-left: 3em;
            font-family: Georgia, Palatino, Verdana, Arial, Helvetica;
            font-size:  0.9em;
        }

            /* This is so called 3rd heading */

        p.column7
        {
            font-style:  italic;
            font-weight: bold;
        }

        @media print { P.column7
        {
            font-style:  italic;
            font-weight: bold;
        }}

        p.column8
        {

        }

        p.column9
        {
            font-weight: bold;
        }

        p.column10
        {
            padding-top: 0;
        }

        em.quote10
        {
            /*
                #FF00FF Fuchsia;
                #0000FF Blue

                #87C0FF casual blue
                #87CAF0

                #A0FFFF Very light blue

                #809F69 = Forest Green , see /usr/lib/X11/rgb.txt

                background-color:

                color: #80871F ; Orange, short of

                # font-family: "Gill Sans", sans-serif;

                line-height: 0.9em;
                font-style:  italic;
                font-size:   0.8em;

                line-height: 0.9em;
                color: #008080;

                background-color: #F5F5F5;
                #809F69; forest green
                #F5F5F5; Pale grey
                #FFf098; pale green
                ##bfefff; #ffefff; LightBlue1

                background-color: #ffefff;

                .................
                #FFFCE7         Orange very light
                #FFE7BF         Orange dark
                #FFFFBF         Orange limon

             */

             /*
             #  See a nice page at
             #  http://www.cs.helsinki.fi/linux/
             #  http://www.cs.helsinki.fi/include/tktl.css
             #
             #  3-4 of these first fonts have almost identical look
             #  Browser will pick the one that is supported
             */

             font-family: lucida, lucida sans unicode, verdana, arial, "Trebuchet MS", helvetica, sans-serif;
             background-color: #eeeeff;
             font-size:   0.8em;
        }

        @media print { em.quote10
        {
            font-style:  italic;
            line-height: 0.9em;
            font-size:   0.8em;
        }}

        p.column11
        {
            font-family: arial, verdana, helvetica, sans-serif;
            font-size: 0.9em;
            font-style: italic;
            color: Fuchsia;
        }

        /* /////////////////////////////////////////////// Format words */

        em.word
        {
            /* #809F69 Forest green */
            color: #80B06A;  /*Darker Forest green */
        }

        strong.word
        {

        }

        samp.word
        {
            color: #4C9CD4;
            font-weight: bold;
            font-family:    "Courier New", monospace;
            font-size:      0.85em;
        }

        span.super
        {
            /* superscripts */
            color: teal;
            vertical-align: super;
            font-family: Verdana, Arial, sans-serif;
            font-size: 0.8em;
        }


        span.word-ref
        {
            color: teal;
        }

        span.word-big
        {
            color: teal;
            font-size: 1.2em;
        }

        span.word-small
        {
            color: #CC66FF;
            font-family: Verdana, Arial, sans-serif;
            font-size: 0.7em;
        }

        /* /////////////////////////////////////////////// Format other */

                /* 7th column starting with double quote */

        span.quote7
        {
            /* color: Green; */
            /* font-style: italic; */
            font-family: Verdana;
            font-weigh: bold;
            font-size: 1em;
        }

                /* This appears in FRAME version: xxx-toc.html */

        div.toc
        {
            font-size: 0.8em;
        }

                /* This appears in picture: the acption text beneath */

        div.picture
        {
            font-style: italic;
        }


                /* This is the document info footer */

        em.footer
        {
            font-size: 0.9em;
        }

        END: Hide from older browsers



    </STYLE>


    <!-- ...................................................... Java code -->

    <SCRIPT TYPE="text/javascript">

        function MakeVisual(obj)
        {
            obj.style.fontWeight = "italic";
        }

        function MakeNormal(obj)
        {
            obj.style.fontWeight = "normal";
        }

        function IgnoreErrors()
        {
            return true;
        }

        window.onerror = IgnoreErrors;

    </SCRIPT>

</HEAD>

<BODY >
</P>
</BLOCKQUOTE>
<HR>
    <A name="document_id"  id="document_id"></A>
    <H1>
    1.0 Document id
    
    </H1>
<BLOCKQUOTE>



<P class="column8">
        <EM><STRONG>$Id: emacs-code-body.html,v 2.10 2004/08/27 22:29:45 jaalto Exp $</STRONG></EM><BR>


<P class="column8">
        This document contains Unix Emacs Lisp programming information. It
        addresses the coding style of Emacs lisp and also presents notes
        about Emacs lisp byte compiler. Emacs Lisp code profiling is also
        examined and some profiling result presented.


</P>
  <A name="what_this_document_is_not" id="what_this_document_is_not"></A>
  <H2>
      1.1 What this document is not
      
  </H2>




        This document won't introduce you to lisp, you must have basic
        knowledge about lisp programming beforehand: functions, local,
        global variables and various forms used in lisp. Mainly, this
        contains no ready solutions, functions, that you could use. There
        may be case studies though.


</P>
  <A name="what_is_this_document" id="what_is_this_document"></A>
  <H2>
      1.2 What is this document?
      
  </H2>




        This document contains some guidelines that were found handy. There
        have also appeared also very good articles in the Usenet Emacs
        newsgroups and many good articles may have passed by, but hope you
        find those included interesting. It is recommended that you first
        read some elementary lisp reference before reading this paper.


<P class="column8">
        Read this document as recommendations, not as strict rules. Adapt
        ideas that seem reasonable to you, and discard the others you feel,
        don't serve your needs.


<P class="column8">
        The <SAMP class="word">Elp</SAMP> (lisp profiling tool) results in the page are
        mainly for curious reader, when he needs some reference how to
        write tight loops, time critical functions. But normally there is
        not much need for optimization in Emacs: you run into performance
        problems very rarely. Be very skeptical when reading the results
        and do not put your blind trust on them.


<P class="column9"><STRONG>
         Used Abbreviations</STRONG>



<P class="column8">
        <SPAN class="word-ref">[jari]</SPAN>      Jari Aalto<BR>
        <SPAN class="word-ref">[kai]</SPAN>       Kai Grossjohann<BR>
        <SPAN class="word-ref">[vladimir]</SPAN>  Vladimir Alexiev<BR>

</P>
</BLOCKQUOTE>
<HR>
    <A name="the_basic_coding_suggestions"  id="the_basic_coding_suggestions"></A>
    <H1>
    2.0 The basic coding suggestions
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="major_rule1_comment_as_much" id="major_rule1_comment_as_much"></A>
  <H2>
      2.1 Major rule1 &ndash; comment as much as possible
      
  </H2>




        Someone else reading your code will appreciate any extra
        explanation that you may have written. Someday the code may also be
        maintained by someone else than you, so bear in mind that the
        would-be-maintainer can take over your code, when you no longer are
        around.


</P>
  <A name="major_rule2_maintenance_comes_first" id="major_rule2_maintenance_comes_first"></A>
  <H2>
      2.2 Major rule2 &ndash; maintenance comes first
      
  </H2>




        Maintenance and readability comes first, never write tight
        code. Functions are easier to read if they are &quot;airy&quot;
        instead. Your code doesn't run any faster, no matter how
        much you shrink it. Some people like to delete all white spaces
        from their functions so that the code lines are stuck together;
        but that is not necessarily the best practice.


<P class="column8">
        Organize parts that belong together, into groups and add dashes or
        anything to make it visible that something important is happening
        (function or condition)


</P>
  <A name="major_rule3_dont_spare_variables" id="major_rule3_dont_spare_variables"></A>
  <H2>
      2.3 Major rule3 &ndash; don't spare variables
      
  </H2>




        Don't be afraid of using many variables. Especially in functions,
        that need local variables. A variable can &quot;self document&quot; the code
        if named properly. Use XEmacs byte compiler to check is you have
        defined variables that you haven't actually used, so that the byte
        compilation results are clean. (<STRONG class="word">Note:</STRONG> The XEmacs byte compiler
        can better catch programming errors than Emacs byte compiler.)


<P class="column8">
        In most cases the possible minor performance penalty of using many
        variables doesn't matter. See the profiling results later in this
        document.


</P>
  <A name="major_rule4_document_your_functions" id="major_rule4_document_your_functions"></A>
  <H2>
      2.4 Major rule4 &ndash; document your functions and variables well
      
  </H2>




        Document your variables and functions well. If functions sets
        globals, say it in the docs (use &quot;References:&quot; tag). Every function
        and variable should have DOC-STRING, because when you do
        <SAMP class="word">describe-symbols</SAMP>, it'll print out the SYMBOL and DOC-STRING. And
        one can even search through the doc strings with <SAMP class="word">super-apropos</SAMP>
        Don't forget that the first line of the doc string should be a
        complete sentence.


<P class="column8">
        Don't you feel frustrated too if staring at this?

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defconst foo-list-storage nil)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Now you have to skim the code to understand how and where the
        variable is used. The original Emacs recommendation has been that
        you do need to document package private variables, like the one
        above. However this recommendation is old and dates back to 18.xx
        days where the doc-strings memory space was a limited resource. In
        new Emacs releases there is dynamic byte compilation option which
        reduces the docstring memory consumption. There is no need to &quot;hand
        optimise&quot; the doc-strings away.


</P>
  <A name="major_rule5_dont_use_tricks" id="major_rule5_dont_use_tricks"></A>
  <H2>
      2.5 Major rule5 &ndash; don't use tricks
      
  </H2>




        Think about new comers when you program, who know nothing about
        lisp. Try to code clearly. Avoid tricks, which is not very frienly
        for readers of your code. At least document well why the code at
        that point looks so complex.


</P>
  <A name="major_rule6_use_byte_compiler" id="major_rule6_use_byte_compiler"></A>
  <H2>
      2.6 Major rule6 &ndash; use byte compiler to check leaks
      
  </H2>




        Check your code for variable leaks in fresh emacs &quot;emacs -q&quot; by
        running <SAMP class="word">M-x</SAMP> <SAMP class="word">byte-compile-file</SAMP> XXX.el. If possible use XEmacs's
        for checking because it reports warnings better.


</P>
  <A name="use_the_error_function." id="use_the_error_function."></A>
  <H2>
      2.7 Use the error function.
      
  </H2>




        Use <SAMP class="word">error</SAMP> command if you cannot continue, or if you think that
        some other program may depend on your code, it is best that the
        other program cannot continue. Don't try unnecerrarily handle
        erorr conditions - it won't work in general with Emacs Lisp,
        like if you have got used to Java's or C++'s <SAMP class="word">throw</SAMP> staements.


</P>
  <A name="make_function_as_general_as" id="make_function_as_general_as"></A>
  <H2>
      2.8 Make function as general as possible
      
  </H2>




        But not so general that it can eat apples and cars. It's &quot;good&quot;,
        when the function doesn't get excessive long: still long <SAMP class="word">cond</SAMP>
        statements are ok. Sometimes you just can't split the task into
        smaller parts or it makes no sense to split the function, oh
        well...use your best judgement.


<P class="column8">
        Still, a long function raises always thoughts about bad coding.
        Usually there may be reusable parts, which can be separated, but
        then, perhaps no. Just make sure you are convinced you need that
        long function, and that's it.

</P>
</BLOCKQUOTE>
<HR>
    <A name="coding_style_issues"  id="coding_style_issues"></A>
    <H1>
    3.0 Coding style issues
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="functions_variable_definitions" id="functions_variable_definitions"></A>
  <H2>
      3.1 Function's variable definitions
      
  </H2>





<P class="column10"><EM class="quote10">
          Unclear code:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>       (defun xx (arg1 arg2 &amp;optional arg3 )
         (let ((foo 1) (bar &quot;xx&quot;) baz-flag point))
          ...
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          Maybe better written as:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>       (defun xx (arg1 arg2 &amp;optional arg3 )
         (let* ((foo         1)                ;temporary counter
                (bar         &quot;xx&quot;)             ;displayed value
                baz-flag
                point)
         ...
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          <STRONG class="word">Tip:</STRONG> To &quot;line up&quot; variables nicely in the let statement use
          some package that can do it, like <EM class="word">tinytab.el</EM>, which is tab
          minor mode.</EM>


<UL>
	<LI>Put initialisations first, then variables that do not need
            initialisations. Here <SAMP class="word">foo</SAMP> and <SAMP class="word">bar</SAMP> are defined before
            <SAMP class="word">baz-flag</SAMP> and <SAMP class="word">point</SAMP>
	<LI>Put each one in separate lines and comment their usages when needed.
	<LI>Try to choose descriptive names for variables. Help reader
            and choose &quot;buffer&quot; instead of &quot;b&quot; or &quot;buf&quot;.
	<LI>Long names are almost always better.
</UL>




</P>
  <A name="let_with_initialised_empty_values" id="let_with_initialised_empty_values"></A>
  <H2>
      3.2 Let with initialised empty values
      
  </H2>




        Let's start with example code:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (let* ((foo '())    ;; A list
             (bar nil)    ;; A truth value
             test)        ;; A scratch variable.
    </TD>
    </TR>
</TABLE>


<P class="column8">
        This effectively causes <EM class="word">foo</EM>, <EM class="word">bar</EM>, <EM class="word">test</EM> to be <EM class="word">nil</EM>. Don't
        give the extra stuff fool you. The programmers intention was to
        clarify, that the foo is a <STRONG class="word">list</STRONG> and by initialising it with ()
        would signify a list context... and so on..


<P class="column8">
        But it can be done it more cleanly. The more symbols there are in
        the view, the less easily can human eye focus to important things.
        Let's try this instead:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (let* (foo-list     ;; A list
             bar-flag     ;; A truth value
             test)        ;; A scratch variable.
    </TD>
    </TR>
</TABLE>


<P class="column8">
        In this case, the variable <EM class="word">names</EM> itself tell where they
        are used, and the missing symbols greatly improve the layout. You
        know, that variable is nil by default, so there is no point of
        assigning an empty list. Less is more, in most cases. In addition,
        when you use these variables inside function body, it's clear all
        the time what that stand for because the names tell them.


</P>
  <A name="there_are_alternatives_to" id="there_are_alternatives_to"></A>
  <H2>
      3.3 There are alternatives to `progn'
      
  </H2>




        <SAMP class="word">progn</SAMP> indents code right very fast and that makes writer to code
        in a tight space. All code examples below give exactly the same
        results.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (if variable                    ;test here
          (progn
             ...it was non-nil , do something))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Sometimes 'cond' statement can be used similarly. It has an implicit
        <EM class="word">progn</EM> form:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (cond
       (variable                      ;test here
        ...code..
        ...code..))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        And there is also <EM class="word">and</EM> command, but it requires that all the
        statements you want to execute return non-nil. This may not be
        exactly usable every time.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (and variable
           ..code..
           ..code..)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Common lisp library, <SAMP class="word">cl.el</SAMP> offers doing the same more cleanly.
        This is even more nicer. Prefer this one:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (eval-when-compile (require 'cl))

      (when variable
        ...code..
        ...code..)
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          <SPAN class="word-ref">[vladimir]</SPAN> ...There are other even worse cases. The worst I can
          think of is mapcar with an inlined function:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (mapcar (function (lambda (e)
                          (do stuff)))
            '(1 2 3))
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          This leaves too few columns for (do stuff). Especially if it
          contains another mapcar. This is much better:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (mapcar
       (function
        (lambda (e)
          (do stuff)))
       '(1 2 3))
    </TD>
    </TR>
</TABLE>

</P>
</BLOCKQUOTE>
<HR>
    <A name="using_global_variables"  id="using_global_variables"></A>
    <H1>
    4.0 Using global variables
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="thoughts_on_globals" id="thoughts_on_globals"></A>
  <H2>
      4.1 Thoughts on globals
      
  </H2>




        Because you will be using globals a lot in Emacs lisp packages,
        couple of words may be in place You probably are shocked by the
        fact that lisp programs use globals (actually prefixed or namespace
        globals) all the time, when you have learned that using globals is
        totally wrong and should be avoided at any costs.


<P class="column8">
        The class variables behave quite alike to global variables
        especially if the class derivation chain is long. Hm, to be strict,
        the scope of the variable just gets larger.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>                  derived classes
      BASE        --&gt;C1 --&gt;C2 --&gt;C3
      public var1               sees BASE's var1
    </TD>
    </TR>
</TABLE>


<P class="column8">
        <SAMP class="word">var1</SAMP> is not real global, because it ceases to exist if the class
        is deleted. But, When you see code like this, where variable is
        &quot;seen&quot; outside of function, the instincts say that we should treat
        <EM class="word">var1</EM> like global. It's temptating to think that local is
        something that is inside function or function block, and variables
        outside of a function, while they may be actually packaged within
        class, are all &quot;globals&quot;. Admittedly this is not very accurate
        distinction, but a practical point of view. In Emacs lisp, the
        variable <EM class="word">scope</EM> is whole package and the variables are <EM class="word">true</EM>
        globals because any other packages can see them too.


<P class="column8">
        In Emacs Lisp you can also abstract the use of globals with the
        degree you want:

<UL>
	<LI>You can use globals directly
	<LI>Indirectly in functions: using the aliasing method described
            in a short moment.
	<LI>Using control functions; that hide the globals from
	            functions (quite strong abstraction)
</UL>




</P>
  <A name="globals_and_emacs_lisp_packages" id="globals_and_emacs_lisp_packages"></A>
  <H2>
      4.2 Globals and emacs lisp packages
      
  </H2>




        They are traditionally used in Emacs packages for


<P class="column8">
	<UL>
	<LI>User options:  nil/non-nil/some value.
</UL>



<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defvar my-global-var t
        &quot;Some docs come here how to use it&quot;)
    </TD>
    </TR>
</TABLE>

<UL>
	<LI>Customisable user functions or hooks. Here user has a choice to
            select his preference function to do the job. Advancer lisp
            programmers traditionally don't even use the default functions
            but program their own and then set these variables to point to
	            their implementations.
</UL>



<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defvar my-collect-function 'my-default-collect-function-1
        &quot;*There are two default choices:
         'my-default-collect-function-1
         'my-default-collect-function-2&quot;)
    </TD>
    </TR>
</TABLE>

<UL>
	<LI>Private, place for package storage. Here the package maintainer
            updates and reads the <SAMP class="word">my-:hash-table</SAMP> during the lifetime of
	            the program.
</UL>



<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defvar my-hash-table nil
        &quot;Private. List of hash elements&quot;)
    </TD>
    </TR>
</TABLE>


</P>
  <A name="aliasing_to_globals_summary" id="aliasing_to_globals_summary"></A>
  <H2>
      4.3 Aliasing to globals &ndash; summary
      
  </H2>




        To clarify: the term aliasing used in next sections doesn't
        mean real aliasing. The variable is not actually referred
        through an alias. When you work with a <EM class="word">alias</EM> variable, you can
        pretend that you actually work with the global variable. The alias
        term is used merely for purposes where you <EM class="word">read</EM> the global when
        you use it in function. You do not <EM class="word">write</EM> to a variable
        aliased like this. We're actually using a copy of variable.


<P class="column8">
        The next sections will describe these benefits better, but the
        advantages of copying the global variables are listed here for
        quick reference:

<UL>
	<LI>When globals are only in <EM class="word">let</EM>, you can see at one glance
            what globals are used in the function. If your function has
            10-20 lines, you can't find the used globals that easily
	<LI>You can add extra comment for each global while it
            is being aliased in <SAMP class="word">let</SAMP>.
	<LI>Function maintenance is simpler: you can lift the global
            from <EM class="word">let</EM> to the argument list of a function without
            touching the function body. You do this if you decide
            that the argument should be passed to function and not
	            read from global.
</UL>




</P>
  <A name="aliasing_to_globals_counter_arguments" id="aliasing_to_globals_counter_arguments"></A>
  <H2>
      4.4 Aliasing to globals &ndash; counter arguments
      
  </H2>





<P class="column10"><EM class="quote10">
          <SPAN class="word-ref">[vladimir]</SPAN> ...If alias is used, the reader has to remember that
          `foo-mode-switch` and `switch` are the same thing. Furthermore,
          when you read the body of the function, foo-mode-switch is
          clearly a global var (perhaps a user option), while you have to
          look back at the 'let' in order to see that 'switch' is one.
          Introducing a second name to the same entity doesn't
          necessarily make anything more clear. There are only a few
          valid reasons to</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (let ((local foo-global)))
          (setq local (car local))
      ;; end
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          full name seems too long. Of course, dabbrev or
          PC-lisp-complete-symbol will help you to write the long names,
          but what will help the reader to read them? of different name.</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (let ((case-fold-search nil))
         (re-search-forward foo bar)   ; respect case
      ;; end
    </TD>
    </TR>
</TABLE>


</P>
  <A name="referring_to_global_variable" id="referring_to_global_variable"></A>
  <H2>
      4.5 Referring to global variable
      
  </H2>




        If any global variables is used in a function, don't use
        them directly, instead put them into function body <SAMP class="word">let*</SAMP> where any
        anyone can see at a glance what variables are used. It also
        make maintaining process much simpler, since the changes have to be
        done into let* only. Prefer putting <EM class="word">globals</EM> <EM class="word">first</EM> <EM class="word">in</EM> <EM class="word">let.</EM>


<P class="column8">
        The other benefit for the maintainer is that if he ever decides to
        move that global to function call <EM class="word">parameter</EM>, the task is easy:
        you just lift the value from let-form to the parameter list, and
        you never have to touch the function <EM class="word">body</EM>, because it uses the
        local variables.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-func ()                ; #1
        (let* ((list  my-mode-alist)   ;copy
               ..other variables..)
          ..BODY..))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        You may later find out that it's actually better to call the
        function with <EM class="word">list</EM> argument, so that function becomes more
        general. Following is the <EM class="word">lifted</EM> <EM class="word">global</EM> version of the previous
        function. Notice that the function body doesn't change in any way.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-mode-func (list)          ; #2 , global is now an argument
        (let* (
               ..other variables..)
          ..BODY..))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        <SPAN class="word-ref">[Vladimir]</SPAN> also suggested that you really don't need this kind of
        abstraction, because converting function from #1a into #2a with
        function that use globals directly is as easy.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-mode-func ()                      ; #1a
          ..BODY..
          (if (memq match my-mode-alist)
              ...)))


      ;;  Now uses paramer, not global variable my-mode-alist
      (defun my-mode-func (my-mode-alist)         ; #2a
          ..BODY..
          (if (memq match my-mode-alist)
              ...)))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Hm. What do you think? I'd say that this is equal to mine what
        comes to lisp. But by using the same name in function argument list
        as for global variable, may makes things confusing, because
        <SAMP class="word">my-mode-alist</SAMP> is originally meant to be global variable and used
        in other functions directly. The key point here was that we
        intended to make function more general, implying that we are
        probably moving it away from this <EM class="word">my-mode</EM> package and including
        it into some general lisp library. If we move this function in #2a
        format, we wouldn't want to keep symbol names(variables), which
        refer to specific package <EM class="word">my-mode</EM>.


<P class="column8">
        Detecting reusable functions from any package is easier if the
        globals are presented in the first let statement.


</P>
  <A name="maintenance_and_deferring_to_global" id="maintenance_and_deferring_to_global"></A>
  <H2>
      4.6 Maintenance and deferring to global
      
  </H2>




        Someone may now think in his mind:


<P class="column10"><EM class="quote10">
          Doesn't that make program more slower, I can avoid those private
          variables and <SAMP class="word">let*</SAMP> altogether if I use globals directly.</EM>



<P class="column8">
        Hm, yes and no; program won't slow down remarkably by the extra
        <SAMP class="word">let*</SAMP> statement. More important is the ease of maintenance and
        ability to add comments beside the let statement, since all
        variables may not be self explanatory. If function
        is very <EM class="word">small</EM>, use could those global variables directly to gain
        some more speed.


<P class="column10"><EM class="quote10">
          But if there is anything more than 10 line long function, for
          clarity's sake, use the alias method to hide the global from the
          actual body of function.</EM>



<P class="column8">
        The only case where you may try to bother to optimise <SAMP class="word">let*</SAMP> out
        is, when function gets called many times. Do you know that the
        function is dangerous to my program's performance? Probably not,
        that's why you sometimes use some lisp profiler (elp.el) to bog
        down speed problems.


</P>
  <A name="deferring_to_global_caution" id="deferring_to_global_caution"></A>
  <H2>
      4.7 Deferring to global, caution
      
  </H2>




        The only exception when alias cannot be made in <EM class="word">let</EM> is
        presented here. We may have to introduce a <EM class="word">control</EM> function to
        read global.  Suppose we have following situation.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-foo ()
        (let* ((table my-:passwd-entries-table) ;; copy global
               point)
      ..code..
      ..code..
      (my-change-passwd-table)                    ;; OOPPS!
         (while table                             ;; error!
           ..do, read content..
           ..code..)))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Obviously it is not possible to read the global beforehand, if it
        will be changed by another function call during the execution of
        current function.


<P class="column10"><EM class="quote10">
          For small amount of globals, 5-10, there is no point to
          make separate control function for reading global, like
          in this following example.</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-foo ()
        (let* (table                      ;; no global copy
               point)
      ..code..
      ..code..
      (my-change-passwd-table)            ;; Watch out!
         (setq table (my-read-passwd))    ;; a macro to read global.

         (while table                     ;; okay now..
           ..do, read content..
           ..code..)))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        The <SAMP class="word">my-read-passwd</SAMP>, is implemented as

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defmacro my-read-passwd ()
        &quot;Returns contents of my-:passwd-entries-table&quot;
          (` my-passwd-entries-table))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Using this single macro is overkill, but it may turn into more
        complex function later, if you decide to use many globals. See next:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defsubst my-read-variable (variable)
        &quot;Returns contents of global variables&quot;
        (cond
         ((eq variable 'passwd)
          my:passwd-entries-table)
         ((eq variable 'user)
          my-user)
         (t
          (error &quot;No such variable '%s'&quot; variable))))

      (my-read-variable 'passwd)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        The function is called with symbol describing the variable. This
        implementation totally hides the global variables from lisp calls
        and from other outside functions. You must decide how strong
        abstraction of data you want: For small programs, you probably
        don't need this kind of strong abstraction, but if the program gets
        bigger and you start having 20-50 globals, you may consider using
        similar global <EM class="word">control</EM> functions.

</P>
</BLOCKQUOTE>
<HR>
    <A name="the_let_forms_in_function"  id="the_let_forms_in_function"></A>
    <H1>
    5.0 The 'let' forms in function
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="using_only_one_let_form" id="using_only_one_let_form"></A>
  <H2>
      5.1 Using only one let form inside function
      
  </H2>




        Nowadays many books and many programmers teach that you should
        define variables inside block where you need them. This is
        perfectly good suggestion and you should follow it in natively
        compiled languages. The advise for Emacs Lisp is: &quot;use when
        appropriate&quot;.


<P class="column8">
        <EM class="word">Note:</EM> There is slight difference in memory usage if you define a)
        all variables at the beginning of function b) along the execution
        of your program, where they are created and destroyed. While the A
        may take couple of bytes overall more memory, the important point
        is the content of the variables. If you put 100 cons cells
        immediately into the variable, that's hogging memory, not the
        variable definition itself.


<P class="column8">
        In practice don't worry about this minor memory increase,
        because creating and destroying a variable increases overhead for
        functions too (multiple let statements), so how do you choose: a
        small memory increase at the beginning of file where you define all
        my variables or do you take chance on adding a slight overhead by
        defining variables while the function executes? In big, complex
        function this could be very important issue, but in short functions
        the choice is insignificant.


<P class="column8">
        Most of the time you can use only one <SAMP class="word">let*</SAMP> because it helps
        keeping function layout clearer, while admittedly that there are
        very good reasons when you could consider using multiple <SAMP class="word">let*</SAMP>
        statements. you can arrange the inner body of function to self
        standing blocks by using many let statements and introduce new let
        statements where logically appropriate and many lisp programmers
        recommend that you do so.


<P class="column8">
        In C++ using block local variables is pretty nice looking.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ..FUNCTION START
      if (var == 1)
      {
          int temp = 0                    // local to block if
          if ( condition )
          {
              int tmp = 0                 // this is again local
              ..do something..
          }
      }
    </TD>
    </TR>
</TABLE>


<P class="column8">
        But If we do the same in Emacs lisp, the count of added parentheses
        may be disturbing:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ..FUNCTION START
      (if (= var 1)
          (let ((temp 0))
             (setq tmp (1+ tmp))
             (if condition
                 (let ((tmp 0))
                    (setq tmp (1+ tmp))
                    ..do something..))))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        If we were to write real lisp (not Emacs Lisp), the inner let
        variables could have been be optimized to registers and you should
        definitely use the multiple <SAMP class="word">let</SAMP> statements. In Emacs lisp, this
        kind of optimizatrion does not happen because the code is not
        compiled to native machine code. That's why do not worry so much if
        all the variables are defined at the top-level <SAMP class="word">let</SAMP> and not inside
        later <SAMP class="word">let</SAMP> statements. You won't see any noticeable performance drop if
        you define couple of more variables at the beginning of
        function. That's why you see most of the time this format.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ..FUNCTION START
      (let ((tmp1 0)      ;; Define all used variables
            (tmp2 0))
      (if (= var 1)
          (setq tmp1 (1+ tmp1))
          (if condition
              (setq tmp2 (1+ tmp2))
              ..do something..))))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        The idea for using only one <SAMP class="word">let</SAMP> is that functions look like
        simple. In one <SAMP class="word">let</SAMP> you can see what variables are used in a
        function and decide is some private variable is a candidate for
        global.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      FUNCTION
        VARIABLES
        BODY
    </TD>
    </TR>
</TABLE>


<P class="column8">
        While they could look like this:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      FUNCTION
        VARIABLES
        BODY
          VARIABLE
          BODY
        VARIABLES
        BODY
          VARIABLE
          BODY
    </TD>
    </TR>
</TABLE>


</P>
  <A name="let_form_and_initialising_variables" id="let_form_and_initialising_variables"></A>
  <H2>
      5.2 Let form and initialising variables
      
  </H2>




        But while the variables can be defined without performance penalty,
        postpone initialisation if it takes lot of time. They are
        initialised only just before they are actually used.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-func (var)
        (let* ((re1  (get-re-1))     ; scans whole file.txt, 100Meg
               (re2  (get-re-2))     ;
               tmp)
          (cond
           ((eq 'this var)
            ;; okay we're in business
            (re-search-forward re1 nil t)
            ...

    </TD>
    </TR>
</TABLE>


<P class="column8">
        Instead write code like this, which initialises variable only when
        condition goes into the branch.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-func (var)
        (let* (re1                ; NOTE - No initialisation
               re2                ; NOTE - No initialisation
               tmp)
          (cond
           ((eq 'this var)
            ;; okay we're in business
            (setq re1 (get-re-1))
            (setq re2 (get-re-2)))
            ...
    </TD>
    </TR>
</TABLE>

</P>
</BLOCKQUOTE>
<HR>
    <A name="function_call_arguments_and_return"  id="function_call_arguments_and_return"></A>
    <H1>
    6.0 Function call arguments and return values
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="using_separate_return_value_ret" id="using_separate_return_value_ret"></A>
  <H2>
      6.1 Using separate return value 'ret'
      
  </H2>




        Before going further, remember that all lisp forms return the last
        value which the form executed prior its ending. This is fundament
        of lisp language and whole lisp programming is based on it. The key
        here is that you can make the function's return value more visible:
        the point where the return value is set is obvious.  If we use
        extra variable, say <EM class="word">ret</EM>, over the implicit return value, the
        function is a) easier to debug: you can print the <EM class="word">ret</EM> variable
        anywhere b) easier to follow: setting the return value is obvious
        3) and one exit point is better than &quot;hidden&quot;.


<P class="column10"><EM class="quote10">
          Of course if the function is <EM class="word">very</EM> <EM class="word">small</EM> or extremely simple,
          you don't have use 'ret': return value is already obvious. Use
          your common sense to determine when the extra return variable
          <EM class="word">ret</EM> could clarify the function and when you decide to leave it
          out and use lisp form's side effects of returning value of
          last executed statement.</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-func ()
         (let* (..
                ..)
           ... many lines of code
           (if test
              (cond
                ((= 1 var)
                 ;; IMPLICIT RETURN ))     &lt;---  I wouldn't do this
                (..other-test
                 ;; IMPLICIT RETURN ))     &lt;---  I wouldn't do this
             ... many lines of code
             ...)) ;; let-defun end
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Alternative choice

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-func ()
         (let* (ret
                ..)
            ... many lines of code
            (if test
              (cond
                ((= 1 var)
                 (setq ret (point)))
                ((= 2 var)
                 (setq ret ..)))
              ... many lines of code
              ...)
         ret))  ;; You can put your debugger breakpoint here
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          And here are some extremely simple functions, compared to above
          function that would have had many lines of code. In here, the
          return values are clear.</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun a (b)
        (if b
            3))    ; 'else' case returns nil.

      (defun a (b)
        (cond
         ((...)
          1)                            ;return value
         ((...)
          2)
         (t
          3)))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Another advantage of using <SAMP class="word">ret</SAMP> is, that it jumps into existence
        with default value nil. In function body, you just set it to
        another value if some condition is satisfied, otherwise called
        receives value <SAMP class="word">nil</SAMP> by default.


</P>
  <A name="calling_functions_passing_nonnil" id="calling_functions_passing_nonnil"></A>
  <H2>
      6.2 Calling functions: passing non-nil
      
  </H2>




        <SPAN class="word-ref">[Andrew Fitzgibbon <EM><A HREF="mailto:andrewfg@oculus.aifh.ed.ac.uk" >andrewfg@oculus.aifh.ed.ac.uk</A></EM>]</SPAN> It's common to
        use a descriptive symbol instead of <EM class="word">t</EM> when passing arguments to
        functions. E.g.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (directory-files &quot;~&quot; 'absolute &quot;^[^.#%]&quot;)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        It's a pain then that there's only one nil when you want to default
        an argument, meaning that you can't easily document it. It's just
        occurred to me however that you can write:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (directory-files &quot;~&quot; (not 'absolute) &quot;^[^.#%]&quot;)
    </TD>
    </TR>
</TABLE>

</P>
</BLOCKQUOTE>
<HR>
    <A name="interactive_functions_and_message_display"  id="interactive_functions_and_message_display"></A>
    <H1>
    7.0 Interactive functions and message display control
    
    </H1>
<BLOCKQUOTE>

        How should message displaying be controlled in good manner?  If you
        print any messages, you can add variable <STRONG class="word">verb</STRONG> to the optional
        parameter list. This variable should be the last element there;
        unless you have the <SAMP class="word">&amp;rest</SAMP> list of course.  Now, why such an
        recommendation?  Suppose your function is quite time consuming;
        eg. if it does some file handling and it may be a good idea to
        print some messages to the user about the progress stages.


</P>
  <A name="take_one_lack_of_verbosity" id="take_one_lack_of_verbosity"></A>
  <H2>
      7.1 Take one, lack of verbosity control
      
  </H2>




<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-do-files ()
        (let* (...)
           (while
            (message &quot;reading files...&quot;))
             ... do it for 10 secs)
            (message &quot;reading files...done&quot;))))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        This was the traditional way to code it, because the message is
        always printed, no matter how the function is called: interactively
        or by some top level function.


</P>
  <A name="take_two_some_verbosity_control" id="take_two_some_verbosity_control"></A>
  <H2>
      7.2 Take two, some verbosity control
      
  </H2>




<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-do-files ()
        (let* (...)
           (while
             (if (interactive-p)
                 (message &quot;reading files...&quot;))
             ... do it for 10 secs)
           (if (interactive-p)
               (message &quot;reading files...done&quot;))))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Thi may be better implementation. Messages are printed only if the
        user has called fucntion interactively. Do you see anything to
        make better here? If not, let's examine one more example.


</P>
  <A name="take_three_full_control_of" id="take_three_full_control_of"></A>
  <H2>
      7.3 Take three, full control of verbositiness
      
  </H2>




<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-do-files (&amp;optional verb)
        (let* (...)
           (setq verb (or verb (interactive-p)))
           (while
             (if verb
                 (message &quot;reading files...&quot;))
             ... do it for 10 secs)
           (if verb
               (message &quot;reading files...done&quot;))))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        There are couple of interesting points in this solution. First, it
        provides verbosity to the user. Second it provides verbosity to the
        <EM class="word">caller</EM> too. The idea is, that by default the function is verbose
        when user calls it, but it also gives the verbose messages whenever
        someone else calls it..


<P class="column8">
        The function can now be called like this and it keeps the used
        nicely aware of progress:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      M-x my-do-files         --&gt; verbose
    </TD>
    </TR>
</TABLE>


<P class="column8">
        But the functions is recalled with the command with <SAMP class="word">C-x</SAMP> <SAMP class="word">ESC</SAMP>
        <SAMP class="word">ESC</SAMP> followed by re-run with <SAMP class="word">RET</SAMP>, the verbose messages are
        nnot printed.


<P class="column8">
        This actualy makes user function easier to call, because
        you don't have to call them via <SAMP class="word">M-x</SAMP> (or key binding) to get the
        verbose messages (like returning status, state of mode on/off).
        Developers can now turn on particular verbosity of some function if
        they think would be good to display messages to the user while
        function is executing.


</P>
  <A name="using_callinteractively_isnt_always_the" id="using_callinteractively_isnt_always_the"></A>
  <H2>
      7.4 Using call-interactively isn't always the solution.
      
  </H2>




        Aha, now I hear someone claiming that the example 3 drains into
        this simple lisp call if verbosity is required by lisp call

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (call-interactively 'my-do-files)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Yes, it turns on the (interactive-p) test in function, but by using
        this it <EM class="word">also</EM> <EM class="word">activates</EM> <EM class="word">interactive</EM> <EM class="word">part</EM> of the function. If
        function had the interactive part like this, it would be executed:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-do-files (&amp;optional verb)
        (interactive &quot;sWhat's up doc? &quot;)
        ..code..
        (if (interactive-p)
            (message &quot;this&quot;))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Then the &quot;What's up doc?&quot; prompt would have been popped onto
        screen. The variable 'verb' is needed if the decision of printing
        message is given to the calling function.

</P>
</BLOCKQUOTE>
<HR>
    <A name="overriding_functions"  id="overriding_functions"></A>
    <H1>
    8.0 Overriding functions
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="what_is_that" id="what_is_that"></A>
  <H2>
      8.1 What is that?
      
  </H2>




        Overriding means that the function exists already, but it doesn't
        do exactly what you want --&gt; you want to write your own
        implementation which replaces the function. Sometimes there is Here
        are instructions how you override functions properly. If you just
        want to have some minor modification, then you should look at the
        <EM class="word">advice.el</EM> (std emacs distribution), but to complete replace a
        function, you can fllow steps above.


<P class="column8">
        First, make separate file, where you gather overridden functions.
        You use this file in next sections.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ~/elisp/my/emacs-rc-override.el
    </TD>
    </TR>
</TABLE>


<P class="column8">
        The body of the file looks something like this

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ;;; emacs-rc-override.el --- My implementations
      ;; Override settings of functions for xxxx

      ;; ................................................ forms ...

      &lt;code here&gt;

      ;; ................................................ funcs ...

      &lt;code here&gt;

      (provide 'emacs-rc-override)

      ;;; End of file emacs-rc-override.el
    </TD>
    </TR>
</TABLE>


</P>
  <A name="using_the_evalafterload_hook_trick" id="using_the_evalafterload_hook_trick"></A>
  <H2>
      8.2 Using the eval-after-load hook trick
      
  </H2>




        Let]s start by defining our own <SAMP class="word">mail-signature</SAMP> function
        which is defined in <SAMP class="word">sendmail.el</SAMP>. First the Emacs startup file
        must be modified by adding this code to it:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (eval-after-load &quot;sendmail&quot; '(load &quot;~/elisp/my/emacs-rc-override&quot;))
    </TD>
    </TR>
</TABLE>

<UL>
	<LI>This says that &quot;every time file sendmail is loaded, Emacs
            should execute lisp command (load ...)&quot;.
	<LI>If the sendmail is already loaded into emacs, the form
            executes immediately.
	<LI>If sendmail is already dumped into emacs, you don't need the
            statement at all, but you can load <SAMP class="word">emacs-rc-override.el</SAMP> right
	            away.
</UL>




<P class="column8">
        Next, a function is added to replace the original. Add this code to
        <SAMP class="word">emacs-rc-override.el</SAMP> after the &quot;funcs&quot; section:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun mail-signature (atpoint)
        &quot;My. Sign letter with contents&quot;
         ^^^
        ...code)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        or

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun mail-signature (atpoint)
        &quot;Overridden. Sign letter with contents&quot;
        ^^^^^^^^^^^^
       ...code)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Make sure you add some word like &quot;My&quot; or &quot;Overridden&quot; in front of
        the documentation string, so that when you look up the function
        description with <SAMP class="word">M-x</SAMP> <SAMP class="word">describe-function</SAMP> &lt;func&gt; or <SAMP class="word">C-h</SAMP> <SAMP class="word">f</SAMP>
        &lt;func&gt;, you don't mistakenly believe that is is standard emacs
        function If you overridden 1-2 functions, you may remember which
        ones you have rewritten, but when you start modifying emacs for
        your taste (I have 20-30 overridden functions), you can't remember
        which ones are &quot;true&quot; emacs functions.


<P class="column8">
        Besides, if you post the solution to emacs newsgroups, people will
        appreciate the comment so that they get the describe-function
        information too. Inexperienced user's typically just copy the
        function from the post and if the word <EM class="word">my</EM> is not there they may
        never know later that the function whether it was emacs's default
        or not that they're using...


<P class="column8">
        Now you have the file ready and only thing left is to put one
        statement into your .emacs init file:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (load &quot;~/elisp/my/emacs-rc-override&quot;)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        This loads the file and hooks everything for you. If you later want
        to override some other function, you just open the ~/.emacs.o again
        and (say we override some Gnus functions) add this to the forms
        section and write the function to the <EM class="word">funcs</EM> section in
        <SAMP class="word">emacs-rc-override.el</SAMP>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>          (eval-after-load &quot;gnus&quot; '(load &quot;~/elisp/my/emacs-rc-override&quot;))
                            ^^^^^
    </TD>
    </TR>
</TABLE>


</P>
  <A name="using_advice.el_to_replace_functions" id="using_advice.el_to_replace_functions"></A>
  <H2>
      8.3 Using advice.el to replace functions
      
  </H2>




        Note: When you use advice, make sure that the original behaviour of
        function is preserved. You don't want to break any existing
        packages that may use the advised function.


<P class="column8">
        This is much better way than previously presented
        <SAMP class="word">eval-after-load</SAMP> method. This time you need <EM class="word">advice.el</EM> from
        standard emacs distribution. Why is this better? Because
        advice doesn't wipe out functions permanently, you can turn
        them on and off when needed.


<P class="column8">
        The advice has flag <EM class="word">around</EM> that lets you do things around then
        function: before and after calling it. But if you don't call
        <SAMP class="word">ad-do-it</SAMP> inside advice, then you have effectively replaced the
        function. This is what you need

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defadvice mail-signature (around my act)
        &quot;Replaces function.&quot;
        ...code
        (setq ad-return-value something))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        The important point here is that you say <EM class="word">around</EM> and do not
        include advice macro <SAMP class="word">ad-do-it</SAMP> in the body of function (which
        would call the original function). The advice is put into category
        <EM class="word">my</EM> to refer to your definitions and finally it's put into
        immediate use: <EM class="word">act</EM> means activate now.

</P>
</BLOCKQUOTE>
<HR>
    <A name="using_macros"  id="using_macros"></A>
    <H1>
    9.0 Using macros
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="macros_introduction" id="macros_introduction"></A>
  <H2>
      9.1 Macros introduction
      
  </H2>





<P class="column10"><EM class="quote10">
          Dewey M. Sasser <EM><A HREF="mailto:dewey@newvision.com" >dewey@newvision.com</A></EM></EM>



<P class="column8">
        Macros are (probably) the most difficult thing in LISP to
        understand, especially coming from a background in C or assembly.
        The big key in lisp is that a macro is just a function invoked by
        the evaluator to find out what it should really evaluate. This has
        two big implications:

<UL>
	<LI>Arguments to a macro are not evaluated.
	<LI>Macros can call functions
</UL>




<P class="column8">
        It is not necessary (and because of feature #1, somewhat brain
        twisting) to call a macro from another macro.


<P class="column8">
        When you write a macro, don't think of it as writing a macro, but
        as a function that will be called to translate the arguments (as
        you've specified) from the way they are to some other form. Your
        return value is the form to be executed instead.


<P class="column8">
        For example:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defmacro my-setq (var value)
        (list 'setq var value))

      (macroexpand '(my-setq x y))
      ==&gt;(setq x y)

      (defmacro msf (symbol)
        `(symbol-function (quote ,symbol)))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        But is a bit less obvious.


<P class="column8">
        If you really want to hurt your brain, think about situation where
        you might want to do ',',form (which is valid code and I've seen it
        used, but never had to use it myself). You do this kind of thing
        when you write macros which produce other macros.


</P>
  <A name="a_note_on_lisp_and" id="a_note_on_lisp_and"></A>
  <H2>
      9.2 A note on lisp and &quot;forward declarations&quot;
      
  </H2>





<P class="column10"><EM class="quote10">
          Dewey M. Sasser <EM><A HREF="mailto:dewey@newvision.com" >dewey@newvision.com</A></EM></EM>



<P class="column8">
        Lisp does not have &quot;forward declarations&quot;, as in some other
        languages. In using Lisp, you should make sure that the definition
        has been seen before it is used.


<P class="column8">
        If you define function A using function B, but before function B
        has been defined, it will work, but the byte compiler may not be
        able to check your call to function B. Also, if B is really a macro
        rather than a function, it's definition <EM class="word">must</EM> have been seen
        before it is used. Remember that macros are expanded by the
        byte-compiler and do not actually get compiled into your code. Only
        the results are compiled in.


<P class="column8">
        Anyone who programs in Lisp a lot (and you definitely do) should
        have a copy of <STRONG class="word">Common</STRONG>Lisp:_the_Language_, 2nd Edition, by Guy L.
        Steel. Emacs Lisp is not strictly compatible with the language it
        defines, but Steel's book (commonly referred to as CLtL2) is a very
        good reference and description of how and while. It's not a
        tutorial, but an annotated standard.


<P class="column8">
        Whenever possible, have your macros expand to normal lisp code, the
        way you'd write it if you weren't using macros. Since you wouldn't
        write a normal function like:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (setf (symbol-function 'my-func)
              (function (lambda (x) (do-something x))))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        don't make your macro expand to that unless there's some very good
        reason. If you go look at my modefn.el, where
        <SAMP class="word">modefn::define-mode-specific-function</SAMP> does the real work behind a
        &quot;defmodemethod&quot; call, you'll see that what it's doing is just
        building the proper defun!


<P class="column8">
        This has the advantage of avoiding all of the nasty byte compiler
        tricks necessary to have something compiled as a function (like
        quoting with function, for example) or other things. Also, there's
        really no simple work-around for defvar. You pretty much have to
        use a defvar form. (OK, you could work around it, but it's a lot
        more work.)


<P class="column8">
        I think that if you forget about the code you've written so far (I
        know, that's difficult to do), and rewrite it using what you now
        know, you'll save yourself a lot of work and get better results.


</P>
  <A name="macros_and_autoloading" id="macros_and_autoloading"></A>
  <H2>
      9.3 Macros and autoloading
      
  </H2>




        One important thing that you must remember when using macros is,
        that you must tell in autoload statement explicitly, that that
        defined symbol is a macro. Suppose following.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>          library X: has 100 functions and macros
          library Y: has 100 functions only
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Now user builds his package using code from library Y and X.
        Sophisticated user doesn't want to slurp whole library,
        immediately, but he wants to instruct emacs to load functions on
        demand by adding autoload statements into the code.


<P class="column10"><EM class="quote10">
          Here is simple way to load packages</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>          (require 'X)
          (require 'Y)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Slightly different way is presented below. The function
        <SAMP class="word">y-function-this</SAMP> is loaded from package Y only when is is needed
        somewhere in the code.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>          (require 'X)
          (autoload 'y-function-this &quot;Y&quot;)
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          And the bogus way would be</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>          (autoload 'x-macro-this    &quot;X&quot;)   ;; Wrong
          (autoload 'y-function-this &quot;Y&quot;)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        The last example fails, not during the byte compilation phase &ndash; it
        passes with flying colours, but in the middle of run time function
        it breaks. That's because the user forgot to mention that the the
        <SAMP class="word">x-macro-this</SAMP> is a macro. What actually happened, was that in byte
        compiled file there is <EM class="word">function</EM> call

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>          (x-macro-this)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        But the macro should have been open coded and expanded! The right
        way to use the autoloads is:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>          (autoload 'x-macro-this    &quot;X&quot; 'macro)   ;; okay now
          (autoload 'y-function-this &quot;Y&quot;)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        <STRONG class="word">Tip:</STRONG> See tinylisp.el and command '$ A' in <SAMP class="word">tinylisp-mode</SAMP> which
        creates right autoload statements from any lisp package file.


</P>
  <A name="coding_defmacros_and_name_space" id="coding_defmacros_and_name_space"></A>
  <H2>
      9.4 Coding defmacros and name space problem
      
  </H2>




        This topic is throughly explained in the '(XEmacs lispref)
        Surprising Local Variables' and It is adviced that you read that
        section for better reference. If you have been using macros, you
        probably know about the dynamic scoping problem that may be
        occurring.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defmacro my-macro (&amp;rest body)
        (let* ((counter 0))
           (while (&lt; counter 9)
             (inc counter)
             ;; BODY sees _counter_
             (,@ body))))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        In the code above, macro's <EM class="word">counter</EM> is visible to <EM class="word">body</EM> and if
        there is also user defined &quot;counter&quot;, then there is a serious name
        conflict.


<P class="column8">
        One possible way to avoid this clashing is to use mangled variable
        names in local macros. Because the lisp is case sensitive, you can
        mix upper and lowercase letters to make unique variable name; the
        chance that <EM class="word">body</EM> would have similar name is astronomically small.
        A non-clashing name could have been made from mixing the first and
        last characters:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      CounteR
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Another way to use unique names I learned from a post by
        <EM><A HREF="mailto:wbrodie@panix.com" >wbrodie@panix.com</A></EM> (Bill Brodie), gnu.emacs.help, 23 Aug 1996. He
        quoted my post where I wondered where I could use make-symbol
        command.


<P class="column10"><EM class="quote10">
          &gt; In fact I don't know any use of the command<BR>
          &gt; make-symbol...</EM>
<BR>


<P class="column10"><EM class="quote10">
          Probably its most common use is in writing macros, to make sure
          that a temporary variable introduced into the macro's expansion
          doesn't conflict with any user variables. For example:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defmacro m (x)
        (let ((x-var (make-symbol &quot;x&quot;)))
          (` (let (((, x-var) (, x)))
               ...))))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="macro_or_defun" id="macro_or_defun"></A>
  <H2>
      9.5 Macro or defun
      
  </H2>




<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      | looking thru the advice.el code I notice this definition:
      |
      | (defmacro ad-xemacs-p ()
      |   ;;  Expands into Non-nil constant if we run XEmacs.
      |   ;;  Unselected conditional code will be optimized
      |   ;;  away during compilation.
      |   (string-match &quot;XEmacs&quot; emacs-version))
      |
      | and was wondering what the difference is between using `defmacro'
      | instead of `defun' when no args are used.
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          [Vladimir]</EM>



<P class="column8">
        The above is equivalent to <SAMP class="word">nil</SAMP> on non-xemacs and <SAMP class="word">6</SAMP> (or
        whatever) on emacs. The bytecompiler will compile (if nil (foo)) to
        nothing. If you used a function instead (or a variable), the
        bytecompiler would generate code to call it (fetch its value) and
        accordingly it will include both the emacs and xemacs variants of
        the code. This is slower and produces more code, however there's
        one significant shortcoming of the macro variant: code compiled
        with emacs won't work on xemacs and vice versa This makes it
        impossible to share .elc's one a site that has both emacsen
        installed.


</P>
  <A name="expanding_macros" id="expanding_macros"></A>
  <H2>
      9.6 Expanding macros
      
  </H2>




        It sometimes usefull to expand the macro to really see what
        happend in there. Evaluate these and be amazed

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (macroexpand      '(dolist (i '(1 2)) i))
      (cl-prettyexpand  '(dolist (i '(1 2)) i))

      ;;  XEmacs 19.15 only
      (prettyexpand-sexp '(block nil))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="macro_demonstration_tutorial" id="macro_demonstration_tutorial"></A>
  <H2>
      9.7 Macro demonstration &ndash; tutorial
      
  </H2>





<P class="column10"><EM class="quote10">
          Dewey M. Sasser <EM><A HREF="mailto:dewey@newvision.com" >dewey@newvision.com</A></EM></EM>



<P class="column8">
        As an example, here's my start at the &quot;minor-mode&quot; wizard (you
        know, ever since Microsoft started using that term, I've hated it.)
        This code defines a macro &quot;make-minor-mode&quot;, which can be invoked
        like this:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (make-minor-mode dewey
         &quot;\C-cd&quot; 'insert-dewey
         &quot;\C-cs&quot; 'insert-sasser)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        The above call expands to this:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (progn
        (defvar dewey-minor-mode nil
          &quot;Variable which controls if dewey-minor-mode is active.&quot;)

        (defun dewey-minor-mode (&amp;optional arg)
          &quot;Function which toggles the dewey-minor-mode&quot;
          (setq dewey-minor-mode
              (if (null arg)
                  (not dewey-minor-mode)
                (&gt; (prefix-nume ric-value arg) 0))))

        (setq minor-mode-alist
              (cons (cons (quote dewey-minor-mode) name)
              minor-mode-alist))

        (defvar dewey-minor-mode-keymap nil
          &quot;The keymap for dewey-minor-mode&quot;)

        (if keymap-symbol nil
          (setq dewey-minor-mode-keymap (make-sparse-keymap))
          (define-key dewey-minor-mode-keymap &quot;^Cd&quot; 'insert-dewey)
          (define-key dewey-minor-mode-keymap &quot;^Cs&quot; 'insert-sasser')))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="macro_demonstration_code" id="macro_demonstration_code"></A>
  <H2>
      9.8 Macro demonstration &ndash; code
      
  </H2>





<P class="column10"><EM class="quote10">
          Dewey M. Sasser <EM><A HREF="mailto:dewey@newvision.com" >dewey@newvision.com</A></EM></EM>



<P class="column8">
        Here is the complete macros that are used. Study them carefully.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun minor-mode-variable-symbol (mode)
        &quot;Return the symbol of the minor mode controlling variable.
      Arguement MODE is a symbol&quot;
        (intern (concat (symbol-name mode) &quot;-minor-mode&quot;)))

      (defun minor-mode-make-keymap-symbol (mode)
        &quot;Return the symbol of the minor mode controlling variable.
      Arguement MODE is a symbol&quot;
        (intern (concat (symbol-name mode) &quot;-minor-mode-keymap&quot;)))

      (defun minor-mode-function-name (mode)
        &quot;Return the symbol naming the minor mode function.
      PREFIX can be used to determine which function&quot;
        (intern (concat
                 (symbol-name mode)
                 &quot;-minor-mode&quot;)))

      (defun make-minor-mode-keymap (mode bindings)
        &quot;Define the appropriate keymap&quot;
        (let ((name (symbol-name mode))
              (keymap-symbol (minor-mode-make-keymap-symbol mode)))
        (list
         `(defvar ,keymap-symbol nil
            (concat &quot;The keymap for &quot; name &quot;-minor-mode&quot;))
         `(if keymap-symbol nil
            @(let (results key binding)
                (if (oddp (length bindings))
                    (error &quot;Odd number of keys and bindings&quot;))
                (push `(setq ,keymap-symbol (make-sparse-keymap))
                      results)
                (while bindings
                  (setq key (pop bindings))
                  (setq binding (pop bindings))
                  (push
                   `(define-key ,keymap-symbol ,key ,binding)
                   results))
                (nreverse results))))))

      (defun make-minor-mode-add-to-alist (mode)
        &quot;Add appropriate thing to minor-mode-alist&quot;
        (let ((name (symbol-name mode))
              (variable-symbol (minor-mode-variable-symbol mode)))
          `(setq minor-mode-alist
                 (cons
                  (cons ',variable-symbol name)
                  minor-mode-alist))))

      (defun make-minor-mode-variable (mode)
        (let* ((variable-symbol (minor-mode-variable-symbol mode)))
          `(defvar ,variable-symbol nil
             (concat &quot;Variable which controls if &quot; (symbol-name mode)
                      &quot;-minor-mode is active.&quot;))))

      (defun make-minor-toggle-mode-function (mode)
        &quot;Return the defun form to define the minor mode&quot;
        (let* ((mode-name (symbol-name mode))
               (variable-symbol (minor-mode-variable-symbol mode))
               (function-name (minor-mode-function-name mode)))
          `(defun ,function-name (&amp;optional arg)
             (concat &quot;Function which toggles the &quot;
                      mode-name &quot;-minor-mode&quot;)
                (setq ,variable-symbol
                      (if (null arg) (not ,variable-symbol)
                        (&gt; (prefix-numeric-value arg) 0))))))

      (defmacro make-minor-mode (mode &amp;rest bindings)
        &quot;Define the minor mode functions, etc&quot;
        `(progn
           (make-minor-mode-variable mode)
           (make-minor-toggle-mode-function mode)
           (make-minor-mode-add-to-alist mode)
           @(make-minor-mode-keymap mode bindings)))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="nesting_macros" id="nesting_macros"></A>
  <H2>
      9.9 Nesting macros
      
  </H2>




        Below is a very simple demonstaration how you use <EM class="word">toplevel</EM>
        to call other macros that need symbols as arguments. The
        toplevel expects that the variables are know by name before
        hand.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ;;  some predefined variables

      (defvar my-variable1)
      (defvar my-variable2)

      (defmacro my-internal (sym)
        ;;  Example macro that needs symbol as input argument
        ;;
        (` (symbol-value (, sym))))

      (defmacro my-toplevel (variable-prefix)
        ;;  toplevel uses my-internal macro; Create symbols for calls
        ;;
        (let ((sym1 (intern
                      (concat (` (, variable-prefix)) &quot;-variable1&quot;)))
              (sym2 (intern
                      (concat (` (, variable-prefix)) &quot;-variable2&quot;))))
          (`
           (,@
            (let* (ret)
              ;;  Really, nothing magic here. Since the return value
              ;;  of macro must be a list, we build up list with
              ;;  push command. To return the list in proper order
              ;;  we finally use nreverse.
              ;;
              (push 'progn ret)
              (push (` (my-internal (, sym1))) ret)
              (push (` (my-internal (, sym2))) ret)

              (nreverse ret))))))

      ;;  To check what happens when the macro is expanded

      (macroexpand ' (my-toplevel &quot;my&quot;))

      ;;  And this is the result:
      ;; --&gt; (progn
      ;;       (my-internal my-variable1)
      ;;       (my-internal my-variable2))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="code_nesting_macros_complex_example" id="code_nesting_macros_complex_example"></A>
  <H2>
      9.10 Code: nesting macros, complex example
      
  </H2>




        <SPAN class="word-ref">[vladimir]</SPAN> Here's a macro to define toggle commands.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defmacro v/deftoggle
        (sym &amp;optional get set comment before after message)
        &quot;Define a function v/toggle-SYM to toggle SYM on and off.
      GET and SET are either nil in which case SYM and (setq SYM)
      are used, functions (eg default-value and set-default)
      called with SYM and SYM VAL,
      or (macro lambda (SYM) ...) and
      (macro lambda (SYM VAL) ...) respectively.
      COMMENT is additional comment for v/toggle-SYM,
      BEFORE and AFTER are lists of additional
      forms around the toggle code,
      MESSAGE is a (macro lambda (SYM VAL) ...) replacing the normal
      \&quot;SYM is VAL.\&quot;&quot;
        (cond ((null get) (setq get sym))
              ((symbolp get) (setq get `(,get (quote ,sym))))
              ((setq get (macroexpand (list get sym)))))
        (let ((val `(if arg (&gt; (prefix-numeric-value arg) 0)
                            (not ,get))))
          (cond ((null set) (setq set `(setq ,sym ,val)))
                ((symbolp set) (setq set `(,set (quote ,sym) ,val)))
                ((setq set (macroexpand (list set sym val)))))
          `(defun ,(intern (concat &quot;v/toggle-&quot; (symbol-name sym)))
                  (&amp;optional arg)
             (concat &quot;Toggle &quot; (symbol-name sym)
              &quot;. Return the new value. With positive ARG set it,
              with nonpositive ARG reset it.&quot;
                      (if comment (concat &quot;\n&quot; comment)))
             (interactive &quot;P&quot;)
             @before
             set
             @after
             (if message (macroexpand (list message sym get))
                `(message &quot;%s is %s&quot; (quote ,sym) ,get))
             get)))

      A simple command to toggle a var is defined like this:

      (v/deftoggle bibtex-maintain-sorted-entries)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        This executes some code after toggling the var:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (v/deftoggle debug-on-error nil nil
        &quot;Require 'fdb (filter out trivial errors).&quot; nil
        ((if debug-on-error (require 'fdb))))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        This uses default-value and set-default as the get and set
        functions because url-be-asynchronous is buffer-local, and we need
        to manipulate its global value.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (v/deftoggle url-be-asynchronous default-value set-default)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        This goes wild: it uses special get/set functions and a special message

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (v/deftoggle indented-text-mode
        (macro lambda (sym)
               '(eq major-mode 'indented-text-mode))
        (macro lambda (sym val)
               `(if ,val
                    (progn
                      (make-variable-buffer-local
                       'before-indented-text-mode)
                      (put 'before-indented-text-mode
                           'permanent-local t)
                      ;; so that kill-all-local-variables won't touch it
                      ;;
                      (setq before-indented-text-mode major-mode)
                      (indented-text-mode))
                  (if (boundp 'before-indented-text-mode)
                      (funcall before-indented-text-mode)
                    (normal-mode)
                    (if (eq major-mode 'indented-text-mode)
                        (text-mode)))))
        &quot;Toggle the major mode between indented-text-mode
         and the normal-mode.&quot;
        nil nil
        (macro lambda (sym val) `(message &quot;%s&quot; major-mode)))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="using_macros_to_create_functions" id="using_macros_to_create_functions"></A>
  <H2>
      9.11 Using macros to create functions
      
  </H2>




<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ;; example presented by [kai]

      (defun make-multiplier (n) `(lambda (x) (* ,n x)))
      (fset 'double (make-multiplier 2))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        <SPAN class="word-ref">[Bill Dubuque <EM><A HREF="mailto:wgd@martigny.ai.mit.edu" >wgd@martigny.ai.mit.edu</A></EM>]</SPAN> The above technique does
        not work to create a closure. The point of a closure is that it
        'closes' over (captures) some lexically apparent bindings. The
        exact same binding may be shared by many different closures created
        in the same lexical context. If one of the closures alters the
        value of a closed variable, all the other closures will see the
        change.


<P class="column8">
        E.g. one can use closures to implement data abstractions where the
        closed bindings essentially are state that is hidden by the
        abstraction. Here is a toy example that implements a counter with
        READ and INCREMENT methods:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun make-counter (value)
        (values
          #'(lambda ()                ; READ method
              value)
          #'(lambda (increment)       ; INCREMENT method
              (setq value (+ value increment)))))

      (multiple-value-bind (counter-read counter-incf)
                           (make-counter 1)   ; value &lt;- 1
        (funcall counter-incf 2)              ; value &lt;- value + 2
        (funcall counter-read))               ; read value

      =&gt; 3
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Note how the same lexical binding of 'value' was captured in both
        the READ and INCREMENT closures returned by make-counter.


<P class="column9"><STRONG>
         Dewey M. Sasser <EM><A HREF="mailto:dewey@newvision.com" >dewey@newvision.com</A></EM> comments:</STRONG>



<P class="column10"><EM class="quote10">
          Actually, I found when experimenting that the fset line <EM class="word">is</EM> byte
          compiled. I suppose what that means is that byte-compiler is
          smart enough to treat the argument to &quot;fset&quot; as a function.</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defmacro make-multiplier (n)
         (` (lambda (x) (* (, n) x))))

      (macroexpand ' (make-multiplier 2))
      ;; --&gt; (function (lambda (x) (* 2 x)))

      (fset 'double (make-multiplier 2))
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          However, if you do a</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (setq some-var (make-multiplier 2))
      (fset 'double some-var)
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          I don't think it will be compiled; maybe you have to write</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (setq some-var (make-multiplier 2))
      (fset 'double (byte-compile-sexp some-var))
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          Here is another possibility</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun make-multiplier (func-sym n)
         (let ((name (intern (symbol-name func-sym))))
           (` (defun (, name) (x) (* (, n) x)))))

       ;;;###autoload
       (` (,@ (make-multiplier 'double 2)))
       ;; --&gt; (defun double (x) (* 2 x))
    </TD>
    </TR>
</TABLE>


<P class="column9"><STRONG>
         [*Dewey* comments more]</STRONG>



<P class="column10"><EM class="quote10">
          However, while the real function is installed there,
          the autoload won't notice it. Autoload is a magic text
          thing. When the ;;;###autoload token is read, the
          autoload library uses (read) to read the next form.
          Read does not expand macros (well, only reader macros
          like #', and evidently ` is a reader macro that expands
          to the old-style (` (,a)) syntax). It the above example
          you get nothing (autoload should really be rewritten to be
          extensible).</EM>



<P class="column10"><EM class="quote10">
          If you know the form will expand into &quot;blah-func&quot;, which is a
          function, you can use:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ;;;###autoload (autoload 'blah-func &quot;this-file&quot; &quot;docs&quot;)
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          or whatever the actual call to autoload that you want.</EM>



</P>
  <A name="how_to_read_the_macros" id="how_to_read_the_macros"></A>
  <H2>
      9.12 How to read the macros
      
  </H2>




        When you see some exiting new styled macro, you can convert it
        back to old format with trick presented by <SPAN class="word-ref">[dewey]</SPAN>

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (setq  foo (read (current-buffer)))
      (print foo (current-buffer)) C-u C-x C-e
    </TD>
    </TR>
</TABLE>

</P>
</BLOCKQUOTE>
<HR>
    <A name="using_lambda_notation_some_thoughts"  id="using_lambda_notation_some_thoughts"></A>
    <H1>
    10.0 Using lambda notation &ndash; some thoughts
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="clarification" id="clarification"></A>
  <H2>
      10.1 Clarification
      
  </H2>





<P class="column10"><EM class="quote10">
          <EM class="word">lambda</EM> is same as function, it is just &quot;anonymous&quot; function. So
          everything you can do with real function, you can do with lambda.</EM>



<P class="column8">
        Lisp programmers use lambda functions very often, but many times it
        would be better to see real functions instead. The lambdas have
        their places in lisp, eg. for <SAMP class="word">mapcar</SAMP> and inside macros they are
        often used. But overall, lambdas are not that good.


<P class="column8">
        <SPAN class="word-ref">[Vladimir]</SPAN> also comments: There are several important things
        about using anon functions:

<UL>
	<LI>They can be constructed at run-time, returned from functions,
            stored in structures, etc. Not having to have a name for a
            function can sometimes be a boon, because you don't have to
            divine one for it!
	<LI>They can use the environment of the form they're embedded in.
            Eg they can use the local 'let' variables of the containing
            function without having to pass them as args, use dynamically
	            scoped variables, or make them globals.
</UL>




</P>
  <A name="motivation_to_not_to_use" id="motivation_to_not_to_use"></A>
  <H2>
      10.2 Motivation to not to use lambdas all the time
      
  </H2>




<UL>
	<LI>Real function is cleaner, easy to hand to someone, more easily
            removed from hooks, more... than a <SAMP class="word">lambda</SAMP> form.
	<LI>You can test functions, because you can call them. You can't
            easily test lambdas, because they have no name to call at.
	<LI>You can put functions in separate file; it can be collection of
            useful functions found from the net. For speed reasons you can
            byte compile this separate file. Many lambdas in your .emacs
            just make it look messy, separate function file is more
	            convenient way.
</UL>




<P class="column8">
        Let's see an example. Suppose we want to add some more regexps to
        error identification regexp list when the <EM class="word">compile.el</EM> gets loaded.


<P class="column10"><EM class="quote10">
          Bad choice:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (eval-after-load
        &quot;compile&quot;
        '(progn
           ;; SGI's cc warning message
           (setq compilation-error-regexp-alist
                 (cons
                  ;; IAR C Compiler: &quot;can.c&quot;:390  G
                  '(&quot;\n\&quot;\\(.*\\)\&quot;:\\([0-9]+\\) +.*$&quot; 1 2)
                   compilation-error-regexp-alist))))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        While looking perfectly valid, it has some problems. How do you
        post this answer to someone else? Maybe he already has used some
        other way and he doesn't like this approach. How do you change this
        setup afterwards, especially when your're experimenting with right
        regexps. Gosh! How do I remove the entry from the variable
        <SAMP class="word">eval-after-load</SAMP> ?


<P class="column8">
        In here things are simple. Easily modifiable. And easily handed to
        anyone else.


<P class="column10"><EM class="quote10">
          Possibly better choice:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defvar my-compile-eval-after-form
        '(progn (my-compile-setup))
       &quot;*Form executed when file is loaded.&quot;)

      ;;  Install it

      (eval-after-load &quot;compile&quot; my-compile-eval-after-form)

      ;;  Define my function to handle this

      (defun my-compile-setup ()
       &quot;Installs new regexps to compilation-error-regexp-alist&quot;

        ;;  first save the original, defvar executes only once

        (defvar my-compilation-error-regexp-alist
                 compilation-error-regexp-alist
           &quot;Copy.&quot;)

        ;;  Reset to default, we modify this later

        (setq compilation-error-regexp-alist
              my-compilation-error-regexp-alist)

        ;;  now we can experiment as much as we like by changing
        ;;  contents of these statements

        (setq compilation-error-regexp-alist ; SGI's cc warning message
              (cons
               ;; IAR C Compiler: &quot;can.c&quot;:390  G
               '(&quot;\n\&quot;\\(.*\\)\&quot;:\\([0-9]+\\) +.*$&quot; 1 2)
               compilation-error-regexp-alist)))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Now, there is much more code involved here, but it is more
        portable. Remember the rule: space is cheap, ease of use comes
        first. Now you can also delete the entry easily from the
        <SAMP class="word">eval-after-form</SAMP>.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-delete-eval-after-form (file form)
        &quot;Deletes FORM for FILE form `eval-after-load-alist'&quot;
        (delete form (assoc file after-load-alist)))

      ;; Remove my installation

      (my-delete-eval-after-form &quot;compile&quot; my-compile-eval-after-form)
    </TD>
    </TR>
</TABLE>


</P>
  <A name="putting_lambdas_into_hooks" id="putting_lambdas_into_hooks"></A>
  <H2>
      10.3 Putting lambdas into hooks
      
  </H2>




        The same <SAMP class="word">lambda</SAMP> talk applies to <SAMP class="word">global-set-key</SAMP> and <SAMP class="word">add-hook</SAMP>
        cases It's much cleaner to have function than the lambda. If you
        post the solution, people will appreciate function more than lambda
        solution. Let's try it this way first:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (add-hook 'write-file-hooks
                   '(lambda ()
                     &quot;My checkings&quot;
                     (save-excursion
                       (goto-char (point-min))
                       (if (re-search-forward ....)
                           .. do something fancy
                          .. else))))

    </TD>
    </TR>
</TABLE>


<P class="column8">
        Two obvious notes raise immediately: a) the indentation is
        disturbing, and limits more complex programming b) how do you use
        remove-hook for this ? Not very nice job... Turn this into a
        function and you're back to clear waters.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (add-hook 'write-file-hooks 'my-write-file-hooks)

      (defun my-write-file-hooks ()
        .. whatever)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Advantages: no more lambda, no more indentation problems, you can
        use <SAMP class="word">remove-hook</SAMP> easily, and you can <STRONG class="word">print</STRONG> the hook contents
        nicely with the following. If there were lambdas, the output
        wouldn't be so nice.


<P class="column10"><EM class="quote10">
          (Be in <EM class="word">scratch</EM> buffer, make sure lisp-mode is on, write the
          variable and Hit the C-u .. keys behind a variable)</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      write-file-hooks C-u C-x C-e
    </TD>
    </TR>
</TABLE>


<P class="column8">
        <SPAN class="word-ref">[Vladimir]</SPAN> For short functions to put in hooks/define-keys, I
        prefer to put the function like below. Then I can remove-hook it if
        I need, or re-eval the above to redefine the function, and whatnot.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ;; Defun returns the symbol just defined: the function name
      ;;
      (add-hook 'write-file-hooks
          (defun my-write-file-hooks ()
           .. whatever))
      ;; End
    </TD>
    </TR>
</TABLE>

</P>
</BLOCKQUOTE>
<HR>
    <A name="keeping_your_code_organised"  id="keeping_your_code_organised"></A>
    <H1>
    11.0 Keeping your code organised
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="use_function_separation_dash_lines" id="use_function_separation_dash_lines"></A>
  <H2>
      11.1 Use function separation dash lines
      
  </H2>




        If you have loaded lisp packages from the net, you probably see
        many functions that are there &quot;as is&quot;. Instead of just coding them
        there, you can ease the visibility of the functions by adding
        separator line before every function.


<P class="column10"><EM class="quote10">
          Traditional:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-func1 ()
        (let* (...)
          (save-excursion
           ..)))

      (defun my-func2 ()
        (let* (...)
          (save-excursion
           ..)))

    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          More visible choice:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>        ;;; ---------------------------------------------------------
        ;;;
        (defun my-func1 ()
          (let* (...)
            (save-excursion
             ..)))


        ;;; ---------------------------------------------------------
        ;;;
        (defun my-func2 ()
          (let* (...)
            (save-excursion
             ..)))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        The comments use &quot;;;;&quot;, although &quot;;;&quot; would suffice when the
        comment is outside of function body. According to lisp commenting
        rules the &quot;;;&quot; would have parked to the left hand too. The reason
        is that, when every comment outside of function has &quot;;;;&quot;, I can
        grep my files for &quot;outside&quot; comments. The &quot;;;&quot; style I leave to
        function bodies.


<P class="column8">
        Few packages which might interest you, they all keep your code
        better organised.


<P class="column8">
<SPAN class="quote7">folding.el</SPAN><BR>
        Included in latest XEmacs<BR>
        uses folders {{{ }}}<BR>


<P class="column8">
<SPAN class="quote7">tinybookmark.el</SPAN><BR>
        (b)ook(m)ark package &quot;straight lines with names&quot;<BR>
        provides also X-popup for bookmarks<BR>
        <A HREF="http://tiny-tools.sourceforge.net/" target="_top">http://tiny-tools.sourceforge.net/</A><BR>


<P class="column8">
<SPAN class="quote7">imenu.el</SPAN><BR>
        finding specific funtion, more detailed control.<BR>
        Included in Emacs and XEmacs<BR>


</P>
  <A name="add_autoload_statements" id="add_autoload_statements"></A>
  <H2>
      11.2 Add autoload statements
      
  </H2>




        When you're making a package, don't forget to include those
        important autoload directives to key functions. If your package is
        expected to be put through the emacs build process when
        update-file-autoloads will add your autoloads to loaddefs.el, and
        subsequent dumping of that file with emacs will make them a
        permanent part of the emacs executable. (Usually <SAMP class="word">loaddefs.el</SAMP> is
        dumped, so simply updating it and bytecompiling it won't cause it
        to be loaded at startup time.) Some sysadm may decide to keep your
        packages permanently in his emacs installation and he can rip the
        autoloads from your file with M-x <SAMP class="word">generate-file-autoloads</SAMP>
        (function is defined in autoload.el).

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ;;;###autoload
      (defun my-func ()
    </TD>
    </TR>
</TABLE>

</P>
</BLOCKQUOTE>
<HR>
    <A name="about_lisp_symbol_naming"  id="about_lisp_symbol_naming"></A>
    <H1>
    12.0 About lisp symbol naming
    
    </H1>
<BLOCKQUOTE>

        Common idiom in lisp programs has been that the names contain only
        [-a-zA-Z] characters and so case chosen isn't generally mixed:
        My-Var is bad variable name. Also the traditional package
        definition convention has been:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun  csh-mode-yyy ...
      (defvar csh-mode-xxx ...
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Here the first 'words' always specifies the package that is using
        the name space bucket, here <EM class="word">csh-mode</EM>. Remember that symbol names
        are put to global name space, so each function and each variable
        must be unique.


</P>
  <A name="dont_use_your_initials" id="dont_use_your_initials"></A>
  <H2>
      12.1 Don't use your initials
      
  </H2>




        In <EM class="word">comp.lang.emacs</EM>, <EM class="word">comp.emacs.xemacs</EM> and <EM class="word">gnu.emacs.help</EM>
        where people are likely to post their own solution to other
        peoples, it seems that only few are aware of how they should name
        their symbols properly.  The problem is that if you post code that
        has function name:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      fill-matched
    </TD>
    </TR>
</TABLE>


<P class="column8">
        How do you know afterwards (when you just grab the code and save it
        somewhere in your .emacs or personal &quot;snippet&quot; lib) when you start
        writing code using that function, that it wasn't a Emacs
        distributed function or variable?


<P class="column10"><EM class="quote10">
          The problem arises too, if you name the functions so, that they
          start with your initials:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      joe-fill-matched
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Now, what's wrong with that? Well, if you're going to post such
        code that have lot's of functions and variables starting with
        prefix <SAMP class="word">joe-</SAMP> , people get upset when they save the functions and
        notice that there is someone other's initials involved. They just
        wanted to have some general function to solve current task.


<P class="column8">
        Now, when they ask help again, someone else posts his own functions
        and they end up gathering functions:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      joe-funcs ..
      mike-funcs ..
      bill-funcs ..
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Putting those into <SAMP class="word">.emacs</SAMP> doesn't look pretty.


</P>
  <A name="use_prefix_my_for_private" id="use_prefix_my_for_private"></A>
  <H2>
      12.2 Use prefix my for private symbols
      
  </H2>




        It becomes obvious that it would be nice if everybody would use
        common naming convention, so that the code can be handed to anybody
        without changes. The best way to achieve this is that people use
        prefix:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>          my-
    </TD>
    </TR>
</TABLE>


<P class="column8">
        To denote <STRONG class="word">everything</STRONG> that they own: own variables own functions,
        maps.. Now it's very simple to post that code to someone else, and
        believe me everybody is happy when they receive good and clean code
        without someone else's initial involved. They feel that it's &quot;my&quot;
        code too, to solve &quot;my&quot; problems.


<P class="column8">
        To extend this naming more, people should also use convention:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      my-csh-mode-do-this...
    </TD>
    </TR>
</TABLE>


<P class="column8">
        If it has anything to do with the csh-mode.el, so in general add
        the word <EM class="word">my-</EM> + possible <EM class="word">LIB-ID</EM> if you write some special
        functions for elisp packages. This way you can easily find <STRONG class="word">all</STRONG>
        functions related to &quot;csh-&quot; package with describe-symbol function
        (available in <EM class="word">tinyliby.el</EM> ), including your own.


</P>
  <A name="naming_variables_differently" id="naming_variables_differently"></A>
  <H2>
      12.3 Naming variables differently?
      
  </H2>




        There is still a matter of style with the variable naming. While it
        is possible to program like the &quot;lisp&quot; way, that may not be the
        best bet. In Emacs Lisp, variable and function names do not need to
        differ in any way, so it's perfectly legal to have same name for a
        variable and for a function and for a keymap and .. you name it.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun  csh-mode ()
        ...)

      (defvar csh-mode nil
        &quot;Mode on/off variable&quot;)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        This is both a good and a bad idea. The good part of it is, that
        when you're working with <EM class="word">MODES</EM> or <EM class="word">KEYMAPS</EM>, it's very desirable
        to have same name, so that you know what's going on in the code.


<P class="column8">
        But in the other hand, if you're <STRONG class="word">not</STRONG> using modes, the naming
        convention is .. <EM class="word">hmpf</EM>, confusing. In practical terms
        it's lot more easier to look at the code if the symbol itself
        denotes the <EM class="word">CLASS</EM> where it belongs. If everything looks the same,
        as lisp does due to its nature, it would be welcomed if there were
        something that separate variables from function elements.


</P>
  <A name="separate_naming_of_variables" id="separate_naming_of_variables"></A>
  <H2>
      12.4 Separate naming of variables
      
  </H2>




        In Tiny Tools you have seen another convention. Some has said that
        it &quot;looks ugly&quot;, &quot;I don't like it&quot;, and admittedly it can give
        that impression to the reader of the code.


<P class="column8">
        But managing lisp code gets complicated and hard to maintain if you
        don't develop some aids. A different symbol naming according to
        their CLASSES does help to read my code better and help maintainer to
        see where the variables are and where the functions are. Here is
        one possibility:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-function () ..
      (defvar my-:variable 100)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        There is another benefit from this: it is now possible to grep all
        symbols referring to variables, and there is <EM class="word">no</EM> <EM class="word">false</EM> <EM class="word">hits</EM>,
        It is also posisble to run a program to do the name replacement and
        it succeeds 100%. Variables fromcan be searched from the buffer by
        give <SAMP class="word">my-:</SAMP> prefix to search engine. All in all, navigating in lisp
        code is much more easier.


<P class="column8">
        Have you ever tried to complete the lisp symbols? It's lot nicer
        when you car write <SAMP class="word">my-:</SAMP> prefix and hit <SAMP class="word">lisp-complete-symbol</SAMP>
        command to give you listing of all variables. No false hits
        concerning functions.


<P class="column8">
        Why &quot;:&quot; ? Well, that is familiar to a C++ and Perl programmer and
        The ':' character seems neutral and visible enough to be used in
        the code.


<P class="column8">
        There are also alternative choices, like using &quot;--&quot;, double dash to
        denote variables:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defconst my--var1 &quot;some&quot; &quot;*tmp var&quot;)
      (defconst my--var2 &quot;some&quot; &quot;*tmp var&quot;)
      (defconst my--var3 &quot;some&quot; &quot;*tmp var&quot;)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        <EM class="word">Note:</EM> The colon character is by default in the same syntax class
        as the dash, so your lisp commands like <SAMP class="word">backward-sexp</SAMP> work as
        usual. You can verify this with commands

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (char-to-string (char-syntax ?:)) and
      (char-to-string (char-syntax ?-)) in lisp-mode.
    </TD>
    </TR>
</TABLE>

</P>
</BLOCKQUOTE>
<HR>
    <A name="lisp_code_notes"  id="lisp_code_notes"></A>
    <H1>
    13.0 Lisp code notes
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="callinteractively" id="callinteractively"></A>
  <H2>
      13.1 Call-interactively
      
  </H2>




<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      &gt; If I define a kbd macro, and then name it `say-hi', and I
      &gt; make the kbd
      &gt; macro map to the letters &quot;HI&quot;, then that macro is a command.
      &gt;
      &gt; (defalias 'say-hi (read-kbd-macro &quot;HI&quot;))
      &gt;
      &gt; should end up being interactive. In fact, the expression:
      &gt; (commandp 'say-hi)
      &gt;
      &gt; evals to TRUE.
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          Hrvoje Niksic <EM><A HREF="mailto:hniksic@srce.hr" >hniksic@srce.hr</A></EM>, comp.emacs.xemacs, 13 Apr 1997</EM>



<P class="column8">
        It is, but for a different reason. <SAMP class="word">commandp</SAMP> returns t for
        interactive compiled functions, interactive lambda expressions,
        autoloads with fourth argument non-nil and *string and vectors*.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (commandp [some vector])
    </TD>
    </TR>
</TABLE>


<P class="column8">
        yields t not because <SPAN class="word-ref">[some vector]</SPAN> is a valid command, but because
        it can be callable through <SAMP class="word">execute-kbd-macro</SAMP> or such.
        Documentation for <SAMP class="word">commandp</SAMP> never guarantees that you'll be able
        to <SAMP class="word">call-interactively</SAMP> the objects it blesses with t.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      &gt; The error is when I do this:
      &gt; (call-interactively 'say-hi)
      &gt; I get :
      &gt; wrong type of argument: commandp, say-hi
    </TD>
    </TR>
</TABLE>


<P class="column8">
        That is only a lousy-stated error message. You can call macros with
        <SAMP class="word">execute-kbd-macro</SAMP>.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun maybe-macro-call-interactively (def &amp;rest junk)
        &quot;If DEF is a keyboard macro, execute it, else execute
         it as a command.&quot;
        (if (and (symbolp def)
                 (or (vectorp (symbol-function def))
                     (stringp (symbol-function def))))
            ;; looks like a macro
            (execute-kbd-macro def)
          ;; else just proceed to call-interactively
          (call-interactively def)))
      ;; End
    </TD>
    </TR>
</TABLE>


</P>
  <A name="conditioncase_vs._unwindprotect" id="conditioncase_vs._unwindprotect"></A>
  <H2>
      13.2 Condition-case vs. unwind-protect ?
      
  </H2>





<P class="column10"><EM class="quote10">
          Steven L Baur <EM><A HREF="mailto:steve@miranova.com" >steve@miranova.com</A></EM></EM>



<P class="column8">
        unwind-protect executes the clean up forms whenever the stack is
        unwound by either a throw (non-local exit), or by a signal (error
        condition). Condition-case handles only the error condition and can
        be bypassed by a non-local exit.


<P class="column8">
        Here's some sample code that illustrates the differences: (tested
        on Emacs 19.34 and XEmacs 19.15)

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun test-func (foo)
        &quot;Test Function.&quot;
        (cond (foo (throw 'some-random-condition &quot;Return Result&quot;))
              (t (signal 'error &quot;some-data&quot;))))
      ;; end

      (defun wrapper-1 (foo)
        &quot;Wrapper for test function.&quot;
        (catch 'some-random-condition
            (condition-case err
                (test-func foo)
              (error (message &quot;Caught Error Condition&quot;)))))
      ;; End

      (defun wrapper-2 (foo)
        &quot;Wrapper for test function.&quot;
        (catch 'some-random-condition
            (unwind-protect
                (test-func foo)
              (message &quot;Caught Error Condition&quot;))))
      ;; End
    </TD>
    </TR>
</TABLE>


<P class="column8">
        If you call (wrapper-1 t), the &quot;Caught Error...&quot; message is never
        executed, but if you call (wrapper-2 t) it will be.


<P class="column8">
        In the error signaling case, (wrapper-1 nil) will cause the error
        to be caught and never signalled up. Unwind-protect (wrapper-2
        nil), the error condition does get propagated up. Since this
        appears to be what you want anyway, use unwind-protect.


<P class="column8">
        I hope that makes it a little clearer.


</P>
  <A name="dolist" id="dolist"></A>
  <H2>
      13.3 Dolist
      
  </H2>




        The <SAMP class="word">dolist</SAMP> command loops through a list and it is defined int the
        cl package; you can stop the loop with <SAMP class="word">return</SAMP> command. Below you
        see example and the expansion with <SAMP class="word">cl-prettyexpand</SAMP>.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (dolist (elt '(1 2))
        (if (eq elt 1)
            (return)))        ;Stop the list loop now

      (block nil
        (let ((--dolist-temp--1090818 '(1 2))
              elt)
          (while --dolist-temp--1090818
            (setq elt (car --dolist-temp--1090818))
            (if (eq elt 1) (cl-block-throw '--cl-block-nil-- nil))
            (setq --dolist-temp--1090818 (cdr --dolist-temp--1090818)))
          nil))
    </TD>
    </TR>
</TABLE>


<P class="column4">
    <SAMP class="word">macroexpand</SAMP> to find out the real expansion

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (cl-block-wrapper
       (catch (quote --cl-block-nil--)
         (let ((--dolist-temp--1090818 (quote (1 2))) elt)
           (while --dolist-temp--1090818
             (setq elt (car --dolist-temp--1090818))
             (if (eq elt 1)
                 (cl-block-throw (quote --cl-block-nil--) nil))
             (setq --dolist-temp--1090818 (cdr --dolist-temp--1090818)))
           nil)))
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          Dave Gillespie <EM><A HREF="mailto:daveg@thymus.synaptics.com" >daveg@thymus.synaptics.com</A></EM> comments:</EM>



<P class="column8">
        Common Lisp loops use the Common Lisp <SAMP class="word">block</SAMP> mechanism, not the
        <SAMP class="word">catch</SAMP> mechanism. The Emacs CL package implements <SAMP class="word">block</SAMP> in terms
        of <SAMP class="word">catch</SAMP>, but there is a catch, so to speak.


<P class="column8">
        The CL package treats <SAMP class="word">block</SAMP> specially in order to optimize it.
        <SAMP class="word">Catch</SAMP> blocks are expensive at run-time, so I wanted to make sure
        the compiler could eliminate them when the body code didn't
        actually call <SAMP class="word">return</SAMP>.  (This is especially important since many
        Common Lisp constructs include implicit blocks whether you use
        those blocks or not.)


<P class="column8">
        There were technical reasons, which I don't remember exactly, why
        the optimization was best done in the compiler itself instead of in
        the <SAMP class="word">block</SAMP> macro. Therefore, the CL package has some hacks to
        modify or delay the expansion of <SAMP class="word">block</SAMP> under certain
        circumstances. But this will always be invisible unless you
        deliberately peek at the macro expansions. If you actually try
        using <SAMP class="word">return</SAMP> or <SAMP class="word">return-from</SAMP> in your code, you will find that it
        works properly.


</P>
  <A name="narrowtoregion_dont_use_it_always" id="narrowtoregion_dont_use_it_always"></A>
  <H2>
      13.4 Narrow-to-region &ndash; don't use it always
      
  </H2>




        The <EM class="word">narrow-to-region</EM> lisp form is great if you create functions
        that should do their job in restricted area. Say:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-find-a-region-1 (beg end)
        &quot;Find something from region BEG and END&quot;
        (interactive &quot;r&quot;)
        (let* ((i  0))
          (save-restriction
            (narrow-to-region beg end)
            (PMIN)
            (while (re-search-forward &quot;a&quot; nil t)
              (inc i)))
          (message &quot;%d&quot;  i)))
      ;; End
    </TD>
    </TR>
</TABLE>


<P class="column8">
        There is also another way to write this function by not using the
        narrow at all. I would prefer this another alternative and avoid
        the narrow, because you can take advantage of the END parameter of
        <SAMP class="word">re-search-forward</SAMP>.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun my-find-a-region-2 (beg end)
        &quot;Find something from region BEG and END&quot;
        (interactive &quot;r&quot;)
        (let* ((i  0))
          (save-excursion
            (goto-char beg)
            (while (re-search-forward &quot;a&quot; end t)
              (inc i)))
          (message &quot;%d&quot;  i)))
      ;; End
    </TD>
    </TR>
</TABLE>


</P>
  <A name="obarray_length_and_efficiency" id="obarray_length_and_efficiency"></A>
  <H2>
      13.5 Obarray: length and efficiency
      
  </H2>




        <SPAN class="word-ref">[Jamie Zawinski <EM><A HREF="mailto:jwz@netscape.com" >jwz@netscape.com</A></EM>]</SPAN> ...A vector of length 0 can't
        be used as an obarray. And for performance reasons, an obarray
        should have a length which is prime, and which is roughly the size
        of the number of elements you're going to put into it; The larger
        the ratio of elements/length, the more time lookups will take.

</P>
</BLOCKQUOTE>
<HR>
    <A name="optimizing_and_byte_compiler_tips"  id="optimizing_and_byte_compiler_tips"></A>
    <H1>
    14.0 Optimizing and byte compiler tips
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="use_eq_instead_of" id="use_eq_instead_of"></A>
  <H2>
      14.1 Use eq instead of =
      
  </H2>




        [24 Jan 1996, <EM><A HREF="mailto:terra@diku.dk" >terra@diku.dk</A></EM> (Morten Welinder)] If you're not an
        Emacs wizzard you should skip these patches for now. You may
        benefit later. I have discovered that lots of Emacs Lisp code uses
        <SAMP class="word">equal</SAMP> and <SAMP class="word">=</SAMP> where they could have used <SAMP class="word">eq</SAMP> or even <SAMP class="word">null</SAMP>.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      `equal' is slow and uses a function call.
      `='     is fair but does unnecessary check if we can
              decide in advance that the arguments are integers.
      `eq'    is almost as fast as...
      `null'  ...which is best.
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Examples. Often you see something like these   expressions:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (= (point) (point-min))
      (equal 'foo bar)
      (assoc 'foo bar)
      (equal (current-buffer) buf)
      (eq arg nil)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        which from a functional (and style) point of view are perfectly
        ok. But they're not as efficient as they could be. The ones below
        are better because they use the available type information about
        the arguments.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (eq (point) (point-min))
      (eq 'foo bar)
      (assq 'foo bar)
      (eq (current-buffer) buf)
      (null arg)
    </TD>
    </TR>
</TABLE>


</P>
  <A name="about_setq_and_set" id="about_setq_and_set"></A>
  <H2>
      14.2 About setq and set
      
  </H2>





<P class="column10"><EM class="quote10">
          Simon Marshall <EM><A HREF="mailto:Simon.Marshall@esrin.esa.it" >Simon.Marshall@esrin.esa.it</A></EM> Jan 1997
          in gnu.emacs.help mentined that</EM>



<P class="column8">
        ...One difference not mentioned is that they are byte-compiled
        differently. I think

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (setq fubar foo)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        results in faster byte-code than

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (set 'fubar bar).
    </TD>
    </TR>
</TABLE>


</P>
  <A name="about_let_in_emacs" id="about_let_in_emacs"></A>
  <H2>
      14.3 About let in Emacs
      
  </H2>




        <SPAN class="word-ref">[Hrvoje Niksic <EM><A HREF="mailto:hniksic@srce.hr" >hniksic@srce.hr</A></EM> 1998-03-13 XE-L]</SPAN>

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (setq global 2)
      (setq real-global 3)
      (let (global)
        (setq global 4)
        (setq real-global 5))
      global
      ==&gt; 3

    </TD>
    </TR>
</TABLE>


<P class="column8">
        ...`let' sets up an unwind-protect that remembers the old
        value (2), and places the new value to the symbol value slot (nil
        in this case). When you assign 4 to <SAMP class="word">global</SAMP>, it's written to its
        value slot, overriding <SAMP class="word">nil</SAMP>. When <SAMP class="word">let</SAMP> is left, the internal
        unwind-protect restores the old value (2).


<P class="column8">
        This is one of the reasons why <SAMP class="word">let</SAMP> is extremely slow in Emacs
        Lisp.


</P>
  <A name="make_lambda_to_run_code" id="make_lambda_to_run_code"></A>
  <H2>
      14.4 Make lambda to run code faster
      
  </H2>




        This all is actually explained well in the Emacs lisp pages,
        but let's refresh memory a bit. Let's start with the traditional
        example:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>          (mapcar '(lambda (x) ... )   list)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        The lisp manual page in says that &quot;(elisp, Node: Anonymous
        Functions) ...Lisp compiler cannot assume this list is a function,
        even though it looks like one&quot;. So, we have to help byte compiler
        by adding <SAMP class="word">function</SAMP> directive.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>          (mapcar (function (lambda (x) ... )   list)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Which, when compiled probably speeds the code by factor 2 or more.
        One compatibility not to this: in Emacs 19.29 and up you can
        actually write like this, which is exactly the same as the using
        the <SAMP class="word">function</SAMP> syntax.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>          (mapcar (lambda (x) ... )   list)
    </TD>
    </TR>
</TABLE>


</P>
  <A name="deleting_and_inserting_in_buffer" id="deleting_and_inserting_in_buffer"></A>
  <H2>
      14.5 Deleting and inserting in buffer is slow
      
  </H2>




        <SPAN class="word-ref">[Jerry Quinn <EM><A HREF="mailto:jquinn@nortel.ca" >jquinn@nortel.ca</A></EM>]</SPAN> ...I used to dump data to buffer
        and then moving to a column, making various changes with insert and
        delete-char and moving on to the next change. It would take about
        22 seconds on my system


<P class="column8">
        I now collect the message data into lists with regexps erase the
        buffer and dump the new results in with <SAMP class="word">format</SAMP>. This is MUCH
        faster. (3sec compared to previous 22sec)


</P>
  <A name="byte_compiler_options" id="byte_compiler_options"></A>
  <H2>
      14.6 Byte compiler options
      
  </H2>





<P class="column10"><EM class="quote10">
          18 Sep 1996, Andreas Schwab
          <EM><A HREF="mailto:schwab@issan.informatik.uni-dortmund.de" >schwab@issan.informatik.uni-dortmund.de</A></EM> answered to question
          below</EM>



<P class="column8">
        &gt; (defalias 'pair (symbol-function 'cons))<BR>
        &gt; (defalias 'pairp (symbol-function 'consp))<BR>
        &gt;<BR>
        &gt; The trouble is that the byte-compiler doesn't optimize a<BR>
        &gt; call to e.g. pair as it would do with a call to cons<BR>
        &gt; because it doesn't recognize pair as an alias for cons.<BR>
        &gt;<BR>
        &gt; Is there a way to tell the byte-compiler to treat<BR>
        &gt; pair the same way as cons?<BR>

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (byte-defop-compiler '(pair byte-cons) 2)
      (byte-defop-compiler '(pairp byte-consp) 1)
    </TD>
    </TR>
</TABLE>


</P>
  <A name="byte_compiler_warnings_how_to" id="byte_compiler_warnings_how_to"></A>
  <H2>
      14.7 Byte compiler warnings &ndash; how to get rid of them
      
  </H2>





<P class="column10"><EM class="quote10">
          19 Feb 1996, <EM><A HREF="mailto:andersl@csd.uu.se" >andersl@csd.uu.se</A></EM> (Anders Lindgren)</EM>



<P class="column10"><EM class="quote10">
          &gt; If you have code that depends on a library that is not<BR>
          &gt; always included in a program (be it Emacs Lisp or other<BR>
          &gt; Lisp), the correct way to insure that it's compiled<BR>
          &gt; properly is to do the require. It's not overkill; after<BR>
          &gt; all, a user presumably will only compile it once. And &gt;<BR>
          &gt; it may save you from interactions that you cannot predict<BR>
          &gt; now, e.g., when at some future time when you change your<BR>
          &gt; package or font-lock changes in a future revision of<BR>
          &gt; Emacs.</EM>
<BR>


<P class="column8">
        Genrally this is a good idea. Unfortualtely, when it comes to
        <SAMP class="word">font-lock</SAMP> it's not. It contains a check that it is runed under a
        window system, and barfs at load-time if it's not. This makes it
        impossibel to require the package when compiling in batch mode or
        on a system without a window system.


<P class="column8">
        I have been using a (very ugly) method where I replace statements
        by equivalent statements which doesn't raise the anger of the
        compiler:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      foo              == (symbol-value 'foo)
      (setq foo ...)   == (set 'foo ...)
                         == (funcall (symbol-funtion 'set) 'foo ...)
              (The former fools the Emacs compile but not
               the XEmacs'. The latter fools both.)
      (foo ...)        == (funcall (symbol-function 'foo) ...)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        This type of coding is specially useful when writing programs which
        should be able to run (and compile) under both under Emacs and
        XEmacs. &ndash; Anders


</P>
  <A name="inlining_and_byte_compiler" id="inlining_and_byte_compiler"></A>
  <H2>
      14.8 Inlining and byte compiler
      
  </H2>




        The byte compiler is quite powerfull, but there is only handfull of
        people who really understand how its features can be exploited in
        full. Here is couple of suggestions how you could <EM class="word">force</EM> some
        function to be inlined and thus save the function call, which in
        emacs is quite expensive (see the profiling results later and
        examine eg. mapcar)


<P class="column8">
        Notice that

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      defsubst --&gt; Byte Compiler inlines the function automatically.
    </TD>
    </TR>
</TABLE>


<P class="column8">
        But in case of <EM class="word">func</EM> beeing a regular 'defun' you want to use
        special form <EM class="word">inline</EM> to force inlining the code.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun func (arg)
        (if arg t nil))

      (defun my (x)
        (inline (func xx)))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        See what we got:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ;; You do not need this: (byte-compile 'my)
      ;; because disassemble does it for you
      ;;
      (disassemble  'my)

      byte code for my:
      args: (x)
      0       varref    xx
      1       dup
      2       varbind   arg
      3       goto-if-nil 1
      6       constant  t
      7       goto      2
      10:1    constant  nil
      11:2    unbind    1
      12      return
    </TD>
    </TR>
</TABLE>


<P class="column8">
        As you saw; the <EM class="word">func</EM> was open coded inside function <EM class="word">my</EM>. Here is
        reminder from the byte compiler page:


<P class="column10"><EM class="quote10">
          You can also open-code one particular call to a function without
          open-coding all calls. Use the 'inline' form to do this, like so:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (inline (foo 1 2 3))    ;; `foo' will be open-coded
      (inline                 ;;  `foo' and `baz' will be
        (foo 1 2 3 (bar 5))    ;; open-coded, but `bar' will not.
        (baz 0))
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          You can make a given function be inline even if it has already
          been defined with <SAMP class="word">defun</SAMP> by using the <SAMP class="word">proclaim-inline</SAMP> form
          like so:</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>            (proclaim-inline my-function)
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          This is, in fact, exactly what <SAMP class="word">defsubst</SAMP> does. To make a
          function no longer be inline, you must use <SAMP class="word">proclaim-notinline</SAMP>.
          Beware that if you define a function with <SAMP class="word">defsubst</SAMP> and later
          redefine it with <SAMP class="word">defun</SAMP>, it will still be open-coded until you
          use <SAMP class="word">proclaim-notinline</SAMP>.</EM>



</P>
  <A name="inlining_an_interactive_function_danger" id="inlining_an_interactive_function_danger"></A>
  <H2>
      14.9 Inlining an interactive function, danger ahead
      
  </H2>





<P class="column10"><EM class="quote10">
          <SPAN class="word-ref">[Moral: do not make interactive functions <EM class="word">defsubst</EM>]</SPAN>
          [Sample test file available: test-defsubst.el]</EM>



<P class="column8">
        When I was converting some very small functions from <SAMP class="word">defun</SAMP> to
        <SAMP class="word">defsubst</SAMP>, I run in to this observation. I was wondering what
        inlining would do to functions that had interactive spec. Below the
        terms <EM class="word">IACT</EM> refers to functon that has interactive spec; Here is
        th epseudo code for two functions.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      defsubst fun1
        IACT
        iact-fun1-body

      defun fun2
        IACT
        call fun1
        body
      ;; end

    </TD>
    </TR>
</TABLE>


<P class="column8">
        Now, there is conflict, because when I byte compile <SAMP class="word">fun2</SAMP>, we see

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      defun fun2
        iact-fun1-body
        body
      ;; end
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Where the <SAMP class="word">iact-fun1-body</SAMP> is copied &quot;as is&quot;. And that was what I
        was afraid of. Because iact-fun1-body had (interactive-p) test, it
        gets inserted into wrong place and the whole construction isn't
        what I intended. Here are the results in case you're interested.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defsubst test (&amp;optional arg)
        (interactive &quot;P&quot;)
        (if (interactive-p) (message &quot;Gotchya&quot;)))

      (defun test2 (arg)
        (interactive &quot;P&quot;)
        (test))

      (test2 1)
      --&gt; nothing, this is okay
      (call-interactively 'test2)
      --&gt; &quot;Gotchya&quot;        &lt;&lt; SUPRISE! That wasn't meant to happen!
    </TD>
    </TR>
</TABLE>


<P class="column8">
        byte code for test2 reveals how the inlining happened.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>        args: (arg)
       interactive: &quot;P&quot;
      0       constant  nil
      1       varbind   arg
      2       interactive-p
      3       goto-if-nil-else-pop 1
      6       constant  message
      7       constant  &quot;Gotchya&quot;
      8       call      1
      9:1     unbind    1
      10      return
    </TD>
    </TR>
</TABLE>

</P>
</BLOCKQUOTE>
<HR>
    <A name="profiling"  id="profiling"></A>
    <H1>
    15.0 Profiling
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="test_envinronment" id="test_envinronment"></A>
  <H2>
      15.1 Test envinronment
      
  </H2>




        Here is collection of tests and results I made out of curiosity
        which way is better to code.

<UL>
	<LI>All the functions were in NON-COMPILED form, because the
            compilation optimizes different structures to the same byte
            code. Due to quota limit reasons as well as for bug tracing, I
            usually only use non-compiled elisp pacakges.
	<LI>elp.el v2.39
	<LI>Emacs 19.28
	<LI>HP-UX A.09.01 A 9000/715
</UL>




</P>
  <A name="elp_foreword" id="elp_foreword"></A>
  <H2>
      15.2 Elp foreword
      
  </H2>




        Note, that if you time the same functions you will get different
        absolute timings. Nevertheless, you should get same results about
        the fact that which one feels fastest. The values have been taken
        from the <EM class="word">Elapsed</EM> row: IT DOES NOT REPRESENT EXACT TIME SPENT in
        the function, because time spent depends on of operating system and
        current load of the Unix machine.


<P class="column10"><EM class="quote10">
          <STRONG class="word">Strong</STRONG> <STRONG class="word">Note:</STRONG> <SPAN class="word-ref">[From elp.el, Barry Warsaw]</SPAN> Note that there are
          plenty of factors that could make the times reported unreliable,
          including the accuracy and granularity of your system clock, and
          the overhead spent in lisp calculating and recording the
          intervals. I figure the latter is pretty constant, so while the
          times may not be entirely accurate, I think they'll give you a
          good feel for the relative amount of work spent in the various
          lisp routines you are profiling. Note further that times are
          calculated using wall-clock time, so other system load will
          affect accuracy too.</EM>



<P class="column8">
        Keep in mind that some of the tests may be very stupid or
        misleading to experienced lisp programmer or to person who knows
        Emacs internals very well. My sincere intention has been pure
        curiosity. Please feel free to send any comments or corrections for
        the used tests cases if they are not representative enough. It is
        unfortunate if some test case presented here is totally bogus and
        someone reads it with good intention.


</P>
  <A name="using_elp_for_timing_repeat" id="using_elp_for_timing_repeat"></A>
  <H2>
      15.3 Using elp for timing &ndash; repeat test several times
      
  </H2>




        The elp.el is great, but don't trust the first results. Sometimes
        the timings are totally different if you clear the list and run the
        tests again. Repeat your test cases at least 3 times before you
        derive conclusions about the performance.


<P class="column8">
        In here, the <EM class="word">harness</EM> <EM class="word">count</EM> is mentioned; that means that the
        test has been repeated N times and that the most representative
        time values has been selected(usually average). Using elp, say 10
        times to repeat the test and record the timing, should give you
        solid estimate what timings are right.


<P class="column8">
        You can use the elp very easily via minor mode if you ftp lisp
        helper module: <EM class="word">tinylisp.el</EM>. All the tests have been
        executed with that package in the following manner:

<UL>
	<LI>Draw region over test set, including all functions and
            the HARNESS case and narrow to it with C-x n n
	<LI>read all functions with $ -  <SAMP class="word">tili-eval-current-buffer</SAMP>
	<LI>Instrument all functions with $ e I <SAMP class="word">tili-elp-instrument-buffer</SAMP>
	<LI>Run harness test with $ e h <SAMP class="word">tili-elp-harness</SAMP>
</UL>




<P class="column8">
        After the <SAMP class="word">tili-elp-harness</SAMP> function (where you can give the
        prefix how many times to repeat the test set; defualt is 3) has
        finished the elp results are shown in separate buffer from where
        the average of the results can determined.


</P>
  <A name="byte_compilation_note" id="byte_compilation_note"></A>
  <H2>
      15.4 Byte compilation note
      
  </H2>




        If you byte compile files, the generated code is much faster thnt
        what the non-byte compiled one. During byte compiling, some
        structures are also optimized so that while they may look different
        in the code, the byte code is exactly the same. This means that if
        you should pay attention to tests that show considerable timing
        differencies that probably are not optimized away.


<P class="column8">
        Here are som examples where you see the effect of byte compiling
        Pay attention to cases 1a and 1d which show you fine example how
        byte compilation optimizes structs.


<P class="column8">
        [_1a_] Using <STRONG class="word">let</STRONG> in function.


<P class="column10"><EM class="quote10">
          Here is one long way to read byte code. If you want to byte
          compile expressions withing functions, you probably want
          to be aware of this method too.</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (setq bcode     ;; Simple let with 2 variables
            (byte-compile-sexp
              (defun foo () (let ((a 1) (b 2)) (some-call))) ))
      (disassemble bcode)
    </TD>
    </TR>
</TABLE>


<P class="column10"><EM class="quote10">
          Here shorter way to read byte code; which produces exactly the
          same byte code as previous one. The <SAMP class="word">disassemble</SAMP> compiles the
          sexp automatically.</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (disassemble '(lambda () (let ((a 1) (b 2)) (some-call) )))

      byte code for foo:
        args: nil
      0   constant  1
      1   constant  2
      2   varbind   b
      3   varbind   a
      4   constant  some-call
      5   call      0
      6   unbind    2
      7   return
    </TD>
    </TR>
</TABLE>


<P class="column8">
        [_1b_] Same as previous one, but using the call <STRONG class="word">let*</STRONG>. Notice,
        that the only difference to previous one is the order how the
        variables are pushed into stack. In 1a case all the values were
        pushed there first and then popped in varbind. Internal stack depth
        is thus bigger in <STRONG class="word">1a</STRONG> and according to experts, that makes big let
        statements slightly slower than if one used let* for the same
        purpose.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (disassemble '(lambda () (let* ((a 1) (b 2)) (some-call) )))

      byte code:
        args: nil
      0   constant  1
      1   varbind   a
      2   constant  2
      3   varbind   b
      4   constant  some-call
      5   call      0
      6   unbind    2
      7   return
    </TD>
    </TR>
</TABLE>


<P class="column8">
        [_1c_] Example, where <STRONG class="word">let*</STRONG> binds previous variables. This has same
        byte code as <STRONG class="word">1b</STRONG>.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (disassemble '(lambda () (let* ((a 1) (b a)) (some-call) )))

      byte code for foo:
        args: nil
      0   constant  1
      1   varbind   a
      2   constant  1
      3   varbind   b
      4   constant  some-call
      5   call      0
      6   unbind    2
      7   return
    </TD>
    </TR>
</TABLE>


<P class="column8">
        [_1d_] In the following we use multiple let stetments and the byte
        compiling reports that the byte code is equal to <STRONG class="word">1a</STRONG>. A fine
        example how byte compiler optimizes statements.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (disassemble
        '(lambda ()
           (let ((a 1))
             (let ((b 2))
               (some-call) ))))

      byte code:
        args: nil
      0   constant  1
      1   varbind   a
      2   constant  2
      3   varbind   b
      4   constant  some-call
      5   call      0
      6   unbind    2
      7   return
    </TD>
    </TR>
</TABLE>


<P class="column8">
        [_4_] Things change if there is some call between the let stetments

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (disassemble
        '(lambda ()
           (let ((a 1))
             (call1)
             (let ((b 2))
               (call2) ))))

      byte code:
        args: nil
      0   constant  1
      1   varbind   a
      2   constant  call1
      3   call      0
      4   discard
      5   constant  2
      6   varbind   b
      7   constant  call2
      8   call      0
      9   unbind    2
      10  return
    </TD>
    </TR>
</TABLE>


</P>
  <A name="byte_compiler_can_optimise_smartly" id="byte_compiler_can_optimise_smartly"></A>
  <H2>
      15.5 Byte compiler can optimise smartly
      
  </H2>




        Let me start by and example. I was not sure what the impact of
        <SAMP class="word">callf</SAMP> would be if I used it my code, so I pulled out byte
        compiler and dissassempled some of test defun.


<P class="column8">
        The call (callf or var 0) expand to statement (let* nil (setq var
        (or var 0))), so I wrote three function and compared their
        dissassemble results: They were <STRONG class="word">identical</STRONG>. Generated empty let
        statement was optimised away. This is a good sign that you can
        safely use cl macros.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      [_1_] The cl way

          (defun my1 () (callf or var 0))

      [_2_] The regular code writing way

          (defun my2 () (setq var (or var 0)))

      [_3_] The `callf' like it would macroexpand to

          (defun my3 () (let* nil (setq var (or var 0))))

          byte code for my[1-3 are identical:
            args: nil
          0       varref    var
          1       goto-if-not-nil-else-pop 1
          4       constant  0
          5:1     dup
          6       varset    var
          7       return
    </TD>
    </TR>
</TABLE>

</P>
</BLOCKQUOTE>
<HR>
    <A name="profiling_results"  id="profiling_results"></A>
    <H1>
    16.0 Profiling results
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="refence_functions" id="refence_functions"></A>
  <H2>
      16.1 Refence functions
      
  </H2>




        The format of the test function was presented by <SPAN class="word-ref">[Vladimir]</SPAN> and
        from the timing you can see how much the this <EM class="word">wrapper</EM> affects the
        timings measured. Because the timing is measured from the
        Elapsed(accumulted time) row, here are the reference times for
        different loop-for values: 5 and 10 that are normally used in test.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>       0.32 (10)
       |      |
       |      how many times function is called (loop-for count)
       Elapsed time


      ;;  Reference function, without any extra calls
      ;;
      (defun t01 ()                   ;; 0.16(5) 0.32(10)
        (let ((i    0))
          (while (&lt; i 1000)
              ;;
              ;;  TEST CODE IS PUT HERE
              ;;
              (setq i (1+ i)))))

      ;; function with one parameter
      ;;
      (defun t02 (list)               ;; 0.16(5) 0.32(10)
        (let ((i    0))
          (while (&lt; i 1000)
              ;;
              ;;  TEST CODE IS PUT HERE
              ;;
              (setq i (1+ i)))))

      (when HARNESS                                   ;; 10 times
        (setq list (make-list 200 nil))
        (loop-for 0 5
          (t01) (t02 list) ))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="how_to_get_first_element" id="how_to_get_first_element"></A>
  <H2>
      16.2 How to get first element?
      
  </H2>




        As you can see; there is no difference between the element
        retrieval functions.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun t1 (list)                            ;; 0.4, car
        (let ((i    0))
          (while (&lt; i 1000)
              ;;
              (car list)
              ;;
              (setq i (1+ i)))))

      (defun t2 (list)                            ;; 0.4, nth
        (let ((i    0))
          (while (&lt; i 1000)
              ;;
              (nth 0 list)
              ;;
              (setq i (1+ i)))))


      (defun t3 (list)                            ;; 0.4,elt
        (let ((i    0))
          (while (&lt; i 1000)
              ;;
              (elt list 0)
              ;;
              (setq i (1+ i)))))

      (when HARNESS                               ;;10 times
        (setq list (make-list 200 nil))
        (loop-for 0 10
          (t1 list) (t2 list) (t3 list)))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="how_to_access_last_element" id="how_to_access_last_element"></A>
  <H2>
      16.3 How to access last element?
      
  </H2>




        The results were quite impressive. Naturally using the <SAMP class="word">reverse</SAMP>
        command is slower, because it has to access each elemnt, where
        addressing last element directly is the fastest possible way.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ;;  Reading the last element by counting the position.
      ;;
      (defun t1 (list)
        (let ((i    0))
          (while (&lt; i 1000)
              ;;
              (nth (1- (length list)) list)       ;; 1.3
              ;;
              (setq i (1+ i)))))

      ;; Using the reverse command
      ;;
      (defun t2 (list)
        (let ((i   0))
          (while (&lt; i 1000)
              ;;
              (car (reverse list))                ;; 8.0
              ;;
              (setq i (1+ i)))))

      (when HARNESS                               ;;3 times
        (setq list (make-list 200 nil))
        (loop-for 0 5
          (t1 list) (t2 list)  ))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="which_loop_method_is_faster" id="which_loop_method_is_faster"></A>
  <H2>
      16.4 Which loop method is faster?
      
  </H2>




        There seems to be huge diffrence between <EM class="word">while</EM> and <EM class="word">mapcar</EM>.
        probably due to function call the mapcar does every time when
        passing element to lambda function.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun t1 (list)                            ;; 28, mapcar
        (let ((i    0))
          (while (&lt; i 1000)
              ;;
              (mapcar '(lambda (x) nil) list)
              ;;
              (setq i (1+ i)))))

      (defun t2 (list)                            ;; 0.2, while
        (let ((i    0))
          (while (&lt; i 1000)
              ;;
              (while list nil (setq list (cdr list)))
              ;;
              (setq i (1+ i)))))

      (when HARNESS                               ;;3 times
       (setq list (make-list 200 nil))
        (loop-for 0 5
         (t1 list) (t2 list) ))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="adding_to_list_fast" id="adding_to_list_fast"></A>
  <H2>
      16.5 Adding to list fast
      
  </H2>




        If I want to append things to a list, should I do it with append or
        with nconc or cons? So that results are comparable to each other,
        every function must return the list in the same order and that's
        why you see <SAMP class="word">nreverse</SAMP> calls prior returning the list in some
        functions.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun t11 ()                           ;;3.3, nconc 1
        (let ((i    0)
              list)
          (while (&lt; i 1000)
              ;;
              (setq list (nconc list (list i)))
              ;;
              (setq i (1+ i)))
          list))   ;; (0 1 2 3 ..)


      ;;  Traditional nconc
      ;;
      (defun t12 ()                           ;; 3.3, nconc 2
        (let ((i    0)
              list)
          (while (&lt; i 1000)
              ;;
              (if (null list)
                  (setq list (list i))
                (nconc list (list i)))
              ;;
              (setq i (1+ i)))
           list))   ;; (0 1 2 3 ..)

      (defun t21 ()                           ;; 24.0, append to end
        (let ((i    0)
              list)
          (while (&lt; i 1000)
              ;;
              (setq list (append list (list i)))
              ;;
              (setq i (1+ i)))))

      (defun t22 ()                           ;; 0.5, append to beg
        (let ((i    0)
              list)
          (while (&lt; i 1000)
              ;;
              (setq list (append (list i) list))
              ;;
              (setq i (1+ i)))
           (nreverse list)))  ;; (0 1 2 3 ..)

      (defun t3 ()                            ;; 0.7, list*
        (let ((i    0)
              list)
          (while (&lt; i 1000)
              ;;
              (setq list (list* 1 list))
              ;;
              (setq i (1+ i)))
           (nreverse list)))   ;; (0 1 2 3 ..)


      (defun t4 ()                            ;; 1.0, push
        (let ((i    0)
              list)
          (while (&lt; i 1000)
              ;;
              (push i list)
              ;;
              (setq i (1+ i)))
           (nreverse list)))    ;; (0 1 2 3 ..)

      (defun t5 ()                            ;; 0.3, cons
        (let ((i    0)
              list)
          (while (&lt; i 1000)
              ;;
              (setq list (cons i list))
              ;;
              (setq i (1+ i)))
           (nreverse list)))    ;; (0 1 2 3 ..)


      (when HARNESS                               ;; 3 times
        (loop-for 0 5
          (t11) (t12) (t21) (t22) (t3) (t4) (t5) ))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Wow. using <SAMP class="word">append</SAMP> to add to the end of list is enermously slower
        than when compared to fastest way <SAMP class="word">cons</SAMP>. You should only use
        append to add to the beginning of list.


<P class="column10"><EM class="quote10">
          [Vladimir]</EM>



<P class="column8">
        This is expected. For every call, <SAMP class="word">append</SAMP> traverses to the end of
        the list, making a copy along the way, then adds a new element at
        the end, then discards the old list. This may even lead to garbage
        collection, which can take unpredictably long.


<P class="column8">
        <SAMP class="word">nconc</SAMP> is better in that it doesn't copy the list (&quot;doesn't cons&quot;,
        which means that doesn't create new conses. Cons creation is quick
        when the new cons is taken from the free cons list, but if that is
        exhausted, memory allocation should be done). However, <SAMP class="word">nconc</SAMP>
        still traverses the list at every iteration.


<P class="column8">
        <SAMP class="word">cons</SAMP> just adds a new cell at the beginning.  <SAMP class="word">append</SAMP> and <SAMP class="word">nconc</SAMP>
        take O(n^2/2): when the list length is l they perform O(l)
        operations to traverse the list. cons has amortized cost O(1) (ie
        constant). &quot;Amortized&quot; means that it may cause memory allocation
        and/or garbage collection every once in a while, but most of the
        time it won't.


</P>
  <A name="how_to_copy_a_alist" id="how_to_copy_a_alist"></A>
  <H2>
      16.6 How to copy a alist fast
      
  </H2>




        Idea by Morten Welinder <EM><A HREF="mailto:terra@diku.dk" >terra@diku.dk</A></EM> (copy-sequence
        minor-mode-alist) only copies the cdr structure of the list (mapcar
        'copy-sequence minor-mode-alist) ought to copy the pairs in the
        alist `copy-alist copies' list structure and pairs: it does
        slightly more than we need but it is much faster.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun t1 (list)                                ;; 3.5
        (let ((i    0))
          (while (&lt; i 100)
              ;;
              (mapcar 'copy-sequence list)
              ;;
              (setq i (1+ i)))))

      (defun t2 (list)                                ;; 2.5
        (let ((i    0))
          (while (&lt; i 100)
              ;;
              (copy-list list)
              ;;
              (setq i (1+ i)))))

      (when HARNESS                                   ;;10 times
        ;; Make '((t 1) (t 1) ..) list first.
        (setq list (mapcar '(lambda (x) (list x 1)) (make-list 100 t)))
        (loop-for 0 10
          (t1 list) (t2 list) ))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="let_is_using_let_slower" id="let_is_using_let_slower"></A>
  <H2>
      16.7 Let: is using let* slower than let
      
  </H2>




        See explanation in <A HREF="#let_is_using_let_slower" > (benchmarks)</A> which
        explains the unexpected result where let* is marginally faster.


<P class="column8">
        <SPAN class="word-ref">[Vladimir]</SPAN>


<P class="column8">
        From common sense, it wouldn't matter how you arrange your lets and
        how you init the vars, even if your function is called in a long
        loop. The function call time will still dominate the lets. If
        fc=100 and let=1, a second let will only add 1% to the overall
        time. The only time it matters is when the inner let is inside a
        loop, in which case it will probably pay to take it outside.


<P class="column8">
        We'll find that using let inside loop (defining variable j again
        and again) slightly decreases the performance. Yes, only slightly,
        because you don't normally use 1000 let statements in your
        function. This would also suggest that even if you put several let
        statements into the function, that wouldn't be be very much slower
        that using just one let statement at the beginning of file.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (t01)                               ;; 0.32, without let

      (defun t1 ()                        ;; 0.7, let
        (let ((i 0))
          (while (&lt; i 1000)
             ;;
             (let (j) )
             ;;
             (setq i (1+ i)))))

      (defun t2 ()                        ;; 0.6 let*
        (let ((i 0))
          (while (&lt; i 1000)
             ;;
             (let* (j) )
             ;;
             (setq i (1+ i)))))

      (when HARNESS                       ;;10 times
        (loop-for 0 10
          (t1) (t2)  ))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        It seems that there is not much difference in tested emacs. I
        wouldn't be that thrilled of the results, but I'd guess that let*
        would have been definitely slower that let. Let try with variation
        where let* is used for the purpose is it meant to: binding previous
        values's content.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun t1 ()                        ;; 1.2, let
        (let ((i 0))
          (while (&lt; i 1000)
             ;;
             (let ((a 0) (b 1) (c 1) (d 1) (e 1))   )
             ;;
             (setq i (1+ i)))))

      (defun t2 ()                        ;; 1.1 let*
        (let ((i 0))
          (while (&lt; i 1000)
             ;;
             (let* ((a 0) (b 1) (c b) (d c) (e d)) )
             ;;
             (setq i (1+ i)))))

      (when HARNESS                       ;;10 times
        (loop-for 0 10
          (t1) (t2)  ))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Hm. While the let* binds previous variables values to successive
        ones, there still doesn't seem to be a big difference. Don't pay
        attention to marginal 0.1 advantage which let* seems to have
        gained.


</P>
  <A name="let_or_function_arg_list" id="let_or_function_arg_list"></A>
  <H2>
      16.8 Let: or function arg list
      
  </H2>




        Some times I only need one variable and I have a bad habbit of
        defining it in the function call argument list to save typing and
        indentation of <EM class="word">let</EM> call. Like following.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (setq xxx-function
        '(lambda (&amp;optional ignore)
           (if (setq ignore (my-call-someone))
               (symbol-value ignore))))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Above I only needed one variable, that I named <EM class="word">ignore</EM>, and used
        it to record the return status of function. But does this buy
        anything for me? lets find out.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun  t1 (&amp;optional a) (setq a (ignore)))     ;; 0.11
      (defun  t2 () (let (a) (setq a (ignore))))      ;; 0.12

      (defun t11 ()
        (let ((i    0))
          (while (&lt; i 100)
              ;;
              (t1)
              ;;
              (setq i (1+ i)))))

      (defun t22 ()
        (let ((i    0))
          (while (&lt; i 100)
              ;;
              (t2)
              ;;
              (setq i (1+ i)))))


      (when HARNESS                                   ;; 3 times
        (setq hook nil)
        (loop-for 0 10
          (t11) (t22) ))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        If doesn't seem to matter much. I have just had a bad habbit and I
        should get rid of it.


</P>
  <A name="variables_count_of_them" id="variables_count_of_them"></A>
  <H2>
      16.9 Variables: count of them
      
  </H2>




        The count of variables starts gradually affecting the
        performance. Decide yourself how big threath using many variables
        is to your function: usually there are other statements that affect
        the overall perfomance of the function much more. The function call
        alone takes considerable amount of time when compared to sole let
        statement.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun t1 ()                        ;; 0.5
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (let* (a1 a2 a3) )
            ;;
            (setq i (1+ i)))))

      (defun t2 ()                        ;; 0.7 2x more variables
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (let* (a1 a2 a3 a4 a5 a6) )
            ;;
            (setq i (1+ i)))))

      (defun t3 ()                        ;; 0.9 3x more variables
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (let* (a1 a2 a3 a4 a5 a6 a7 a8 a9) )
            ;;
            (setq i (1+ i)))))

       (when HARNESS                                   ;; 3 times
        (loop-for 0 10
          (t1) (t2) (t3) ))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="variables_using_let_or_setq" id="variables_using_let_or_setq"></A>
  <H2>
      16.10 Variables: using let or setq
      
  </H2>




        I always question myself, does it make difference shere I set the
        variables value. Some times If I complex initializations I would
        like to declare variable (not set it) in let stament and leave the
        initializing after the let. This seems to indicate that using the
        let to set the variables is better.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun t1 ()                                    ;; 2.7
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (let ((str1 (format &quot;%s&quot; &quot;1&quot;))
                  (str2 (format &quot;%s&quot; &quot;1&quot;))
                  (str3 (format &quot;%s&quot; &quot;1&quot;))
                  (str4 (format &quot;%s&quot; &quot;1&quot;)))
            ;;
            (setq i (1+ i))))))

      (defun t2 ()                                    ;; 3.5
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (let (str1 str2 str3 str4)
              (setq str1 (format &quot;%s&quot; &quot;1&quot;)
                    str2 (format &quot;%s&quot; &quot;1&quot;)
                    str3 (format &quot;%s&quot; &quot;1&quot;)
                    str4 (format &quot;%s&quot; &quot;1&quot;)))
            ;;
            (setq i (1+ i)))))

      (when HARNESS                                   ;;10 times
        (loop-for 0 10
          (t1) (t2) ))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="variables_many_setq_commands" id="variables_many_setq_commands"></A>
  <H2>
      16.11 Variables: many *setq* commands
      
  </H2>




        Yes they do. Using one setq command is naturally faster than many
        of them. For comparision there is t0 function which does the same,
        but does not use setq at all.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ;;  Reference function
      ;;
      (defun t0 ()                                    ;; 1.1
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (let ((a 1) (b 1) (c 1) (d 1) (e 1) (f 1) (g 1) ))
            ;;
            (setq i (1+ i)))))

      (defun t1 ()                                    ;; 1.4
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (let (a b c d e f g)
              (setq a 1  b 1 c 1 d 1 e 1 f 1 g 1))
            ;;
            (setq i (1+ i)))))

      (defun t2 ()                                    ;; 1.9
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (let (a b c d e f g)
              (setq a 1) (setq b 1 ) (setq c 1 ) (setq d 1 )
              (setq e 1) (setq f 1 ) (setq g 1 ))
            ;;
            (setq i (1+ i)))))

      (when HARNESS                                   ;;3 times
        (loop-for 0 10
          (t0) (t1) (t2)  ))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="if_and_cond_which_is" id="if_and_cond_which_is"></A>
  <H2>
      16.12 If and cond, which is faster one?
      
  </H2>




        Neither. Common sense tells you that too: this is actually a stupid
        test, but I was curious what elp says. From here you can see that
        elp.el isn't that bad if you use it for timing.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun t1 ()                                    ;; 0.4
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (if t nil)
            ;;
            (setq i (1+ i)))))


      (defun t2 ()                                    ;; 0.4
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (cond (t nil))
            ;;
            (setq i (1+ i)))))

      (when HARNESS                                   ;;10 times
        (loop-for 0 10
          (t1) (t2) ))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="concat_and_format_commands" id="concat_and_format_commands"></A>
  <H2>
      16.13 Concat and format commands
      
  </H2>




        I have very hard time to determine which elp results would describe
        the average timing difference. I ran the elp test several times,
        but the deviation between the results were too <STRONG class="word">big</STRONG> to give any
        reliable estimate. Be very skeptical.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun t1 ()                                    ;; 1.2
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (concat &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot;)
            ;;
            (setq i (1+ i)))))


      (defun t2 ()                                    ;; 1.0
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (format &quot;%s%s%s%s%s%s%s%s&quot;
                    &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot;)
            ;;
            (setq i (1+ i)))))

      (when HARNESS                                   ;; 5 times
        (loop-for 0 10
          (t1) (t2) ))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="using_if_before_running_runhooks" id="using_if_before_running_runhooks"></A>
  <H2>
      16.14 Using *if* before running run-hooks
      
  </H2>




        I just wonder if it makes sense to test hook contents before
        running it. Why should I call function run-hooks if there is
        nothing in a hook? From the results point of view, the there is
        small time difference: we prevent a function call to <SAMP class="word">run-hooks</SAMP>.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun t1 ()
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (run-hooks 'hook)                         ;;0.83
            ;;
            (setq i (1+ i)))))


      (defun t2 ()
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (if hook (run-hooks 'hook))
            ;;
            (setq i (1+ i)))))

      (when HARNESS                                   ;; 0.41
        (defconst hook nil &quot;temp hook variable&quot;)
        (loop-for 0 10
          (t1) (t2) ))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="returning_boolean_or_data_from" id="returning_boolean_or_data_from"></A>
  <H2>
      16.15 Returning boolean or *data* from function
      
  </H2>




        Supposes you have some data in some variable, but you wonder does
        ot make a difference to return that data to calling program or just
        plain boolean t or nil


<P class="column8">
        Consider that we have some string data that we <STRONG class="word">could</STRONG> return to
        mean True value, or success. The t2 changes the final return value
        to boolean.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ;; Remark: this is actually not a very good test set.
      ;;
      (defun  t1 () (let ((ret a)) (setq ret a) ret))
      (defun  t2 () (let ((ret a)) (setq ret a) (setq ret t) ret))

      (when HARNESS                               ;; 3 times
        (setq a (make-string (* 2 80) ?a))
        (loop-for 0 500
         (t1)                                     ;; 0.13
         (t2)))                                   ;; 0.13
    </TD>
    </TR>
</TABLE>


<P class="column8">
        No, it doesn't seem to make any difference, so we just return
        anything we have already in the variable.


<P class="column10"><EM class="quote10">
          <SPAN class="word-ref">[Vladimir]</SPAN> ...There is nothing that could slow down the t1
          function, because returning the variable does not make copy of
          it, it only delays garbage collection of that structure for a
          while.</EM>



</P>
  <A name="calling_length_or_using_len" id="calling_length_or_using_len"></A>
  <H2>
      16.16 Calling length or using len variable
      
  </H2>




        If you use the length of list in many places, calculating it every
        time with <SAMP class="word">length</SAMP> function decreases performance considerably.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defun t1 ()                                   ;; 2.3
        (let ((i 0))
          (while (&lt; i 1000)
            ;;
            (progn  (length list) (length list) (length list))
            ;;
            (setq i (1+ i)))))

      (defun t2 ()
        (let ((i 0)
              (len (length list)))                    ;; 0.5
          (while (&lt; i 1000)
            ;;
            (progn  len len len)
            ;;
            (setq i (1+ i)))))

      (when HARNESS                                   ;; 3 times
        (setq list (make-list 100 nil))
        (loop-for 0 10
          (t1) (t2) ))
    </TD>
    </TR>
</TABLE>

</P>
</BLOCKQUOTE>
<HR>
    <A name="xemacs_and_emacs_compatibility"  id="xemacs_and_emacs_compatibility"></A>
    <H1>
    17.0 Xemacs and Emacs compatibility
    
    </H1>
<BLOCKQUOTE>


</P>
  <A name="about_compatibility" id="about_compatibility"></A>
  <H2>
      17.1 About compatibility
      
  </H2>




        During development of my packages I run into many incompatibities
        not only between Emacs and XEmacs, but also between Emacs
        version. If you care to write XEmacs and Emacs compatible code
        without hashless, I'd recommend using fucntions from my main
        library: they offer transparent interface to certain Emacs and
        XEmacs specific features. See these libraries and funcktions

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      tinylib.el   -- functions ti::xe-*
      tinylibxe.el -- XEmacs and Emacs emulation library
    </TD>
    </TR>
</TABLE>


</P>
  <A name="overlay_and_extent_compatibility" id="overlay_and_extent_compatibility"></A>
  <H2>
      17.2 Overlay and extent compatibility
      
  </H2>




        Good news! XEmacs 19.15 now has package overlay.el which mimics the
        calls of Emacs <EM class="word">overlay</EM> functions. This means, that you no longer
        need to try to accomodate both Emacs(overlay) and XEmacs(extent)
        commands into your code. Following is enough to make your overlay
        code work in XEmacs.

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (eval-and-compile
        (if (xemacs-p)
            (load &quot;overlay&quot;)))
    </TD>
    </TR>
</TABLE>


</P>
  <A name="portable_menus" id="portable_menus"></A>
  <H2>
      17.3 Portable Menus
      
  </H2>




        Don't use Emacs specific menus, but see easymenu.el and compose
        your menus with it. Below you see a very simple minor mode and it's
        menu definition. The menu appears when the minor mode is turned on
        and disappears when the minor mode is turned off (at least in
        Emacs). Pay attention to the <STRONG class="word"><EM class="word">Selection</EM></STRONG> <STRONG class="word"><EM class="word">3</EM></STRONG> that can be
        enabled and disabled on the fly.


<P class="column10"><EM class="quote10">
          <STRONG class="word">Note</STRONG>: The easymenu's enable/disable choice is buggy in Emacs
          19.28 - 19.34 (in non-windowed mode), so if the <SAMP class="word">progn</SAMP> tests at
          the end of file fail, don't mind that. Newer Emacs releases have
          fixed the problems.</EM>


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      ;; test.el -- Just sample .el file

      (require 'easymenu)
      (require 'cl)


      (defconst my-map (make-sparse-keymap))
      (defconst my-menu nil)
      (defconst my-mode nil)
      (defvar   my-flag nil)

      (define-key my-map &quot;\ez1&quot; 'my-1)
      (define-key my-map &quot;\ez2&quot; 'my-2)
      (define-key my-map &quot;\ez3&quot; 'my-3)

      (easy-menu-define
         my-menu
         (if (boundp 'xemacs-logo) nil (list my-map))
         &quot;My test menu&quot;
         (list
          &quot;My Menu&quot;
          [&quot;Selection 1&quot; my-1 t]
          ;;
          ;;  X window note:
          ;;  Works in 19.14, but not in Emacs.
          ;;
          ;;  This is a bug in 19.34 but will be
          ;;  corrected to later release
          ;;
          [&quot;Selection 2&quot; my-2 nil]
          ;;
          ;;  let's try something more fancier here.
          ;;
          [&quot;Selection 3&quot; my-3 (get 'my-menu 'menu-flag) ]))


      ;;  Add mode to minor mode list
      ;;
      (unless my-flag                         ;Add only once
        (setq my-flag t)
        (push (cons 'my-mode my-map)  minor-mode-map-alist))

      (defun my-1 () (interactive) (message &quot;1&quot;))
      (defun my-2 () (interactive) (message &quot;2&quot;))
      (defun my-3 () (interactive) (message &quot;3&quot;))


      ;;   Toggle mode and add the menu, not the menu is available
      ;;
      (setq my-mode nil)
      (setq my-mode t)
      (easy-menu-add my-menu)

      ;; X window note:
      ;; Trying this does not enable choice &quot;3&quot; in XEmacs 19.14
      ;; In Emacs 19.30 it works ok.
      ;;
      ;; (progn (put 'my-menu 'menu-flag t) (force-mode-line-update))
      ;; (progn (put 'my-menu 'menu-flag nil) (force-mode-line-update))


      ;; Another Test, you need this in XEmacs, but not actually
      ;; in Emacs. --&gt; Use it for portability.
      ;;
      ;; (easy-menu-remove my-menu)

      ;; end of code
    </TD>
    </TR>
</TABLE>


</P>
  <A name="list_of_simple_incompatibilities." id="list_of_simple_incompatibilities."></A>
  <H2>
      17.4 List of simple incompatibilities.
      
  </H2>




        Here is a small list of functions that do not work in both emacs
        versions.

<UL>
	<LI>force-mode-line-update, XEmacs, labeled as obsolete
	<LI>mailabbrev package, XEmacs, calls it mail-abbrevs
	<LI>transient-mark-mode, does not exist in XEmacs 19.14
	<LI>mailabbrev package, XEmacs, calls it mail-abbrevs
	<LI>eval-after-load, XEmacs, function does not exist in 19.14
	            Use instead:
</UL>



<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (defvar XXX-package-load-hook nil &quot;&quot;)
      ..code..
      (run-hooks 'XXX-package-load-hook)
      ;; End of package XXX.el

      XEmacs 19.15 and 20.1 does have this form though.
    </TD>
    </TR>
</TABLE>


</P>
  <A name="hash_table_compatibility" id="hash_table_compatibility"></A>
  <H2>
      17.5 Hash table compatibility
      
  </H2>




        Hrvoje Niksic <EM><A HREF="mailto:hniksic@srce.hr" >hniksic@srce.hr</A></EM> 17 May 1997 comp.emacs.xemacs


<P class="column8">
        Use CL package's hash function which are compatible with Common
        Lisp and GNU Emacs. They use XEmacs hashtables on XEmacs and
        emulate CL hashtables on GNU Emacs.


<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (let ((foo (make-hash-table :test 'equal)))
        (setf (gethash &quot;David&quot; foo) 'cool)
        (setf (gethash &quot;Hrvoje&quot; foo) 'wow)
        ...

        foo
          =&gt; #&lt;hashtable 2/29 0x1ef7&gt;
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Now, if you want to dump the hash-table anywhere, the simplest
        thing to do is dump it to a list. For example, your program
        crunches data in and out of hashtable for

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (let (alist)
        (maphash (lambda (key val)
                   (push (cons key val) alist))
                 foo)
        alist)
        =&gt; ((&quot;Hrvoje&quot; . wow) (&quot;David&quot; . cool))
    </TD>
    </TR>
</TABLE>


<P class="column8">
        There you have all your entries in <SAMP class="word">alist</SAMP>, which you can print,
        save to file etc. All of this is, of course, much faster than if
        you had used an alist all the time, since the search time would
        have been O(n) instead of much better hashtable characteristics.


</P>
  <A name="character_handling_changes" id="character_handling_changes"></A>
  <H2>
      17.6 Character handling changes
      
  </H2>




        If you had any character tests in your code, it will likely
        break in XEmacs20 and Emacs20, where a single integer does
        no longer present a charcter code. Beware especially contructs
        where you read characters directly and test the input:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (setq ch (read-char))
      (if (memq ch '(?y ?Y))
          ...
    </TD>
    </TR>
</TABLE>


<P class="column8">
        That will no longer work as expected. Also if you have test like
        this

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (if (eq (following-char) ?.)
          ...
    </TD>
    </TR>
</TABLE>


<P class="column8">
        Those will fail also because you can't use old operators like <SAMP class="word">eq</SAMP>.
        In my latest 'm' library there is emulation for some of the
        following functions that are from XEmacs20's documentation. The
        above example can now be converted into

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      (require 'tinylibm)
      (if (char-in-list-case ch '(?y ?Y))

      (if (char= (following-char) ?.)
    </TD>
    </TR>
</TABLE>


<P class="column8">
        And the code will work in every Emacs 19.28+, XEmacs 19.14+.


<P class="column7"><EM><STRONG>
       17.6.1 Characterp: (object), XEmacs20</STRONG></EM>



<P class="column8">
        t if OBJECT is a character. Unlike in FSF Emacs, a character
        is its own primitive type. Any character can be converted into
        an equivalent integer using <SAMP class="word">char-to-int</SAMP>. To convert the
        other way, use <SAMP class="word">int-to-char</SAMP>; however, only some integers can
        be converted into characters. Such an integer is called a
        <SAMP class="word">char-to-int</SAMP>; see <SAMP class="word">char-int-p</SAMP>.


<P class="column8">
        Some functions that work on integers (e.g. the comparison
        functions &lt;, &lt;=, =, /=, etc. and the arithmetic functions +, -,
        *, etc.)  accept characters and implicitly convert them into
        integers. In general, functions that work on characters also
        accept char-ints and implicitly convert them into characters.
        WARNING: Neither of these behaviors is very desirable, and they
        are maintained for backward compatibility with old E-Lisp
        programs that confounded characters and integers willy-nilly.
        These behaviors may change in the future; therefore, do not
        rely on them. Instead, use the character-specific functions
        such as <SAMP class="word">char=</SAMP>.


<P class="column7"><EM><STRONG>
       17.6.2 Char-int (ch) XEmacs20</STRONG></EM>



<P class="column8">
        &ndash; a built-in function. Convert a character into an equivalent
        integer. The resulting integer will always be non-negative. The
        integers in the range 0 - 255 map to characters as follows:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      0 - 31      Control set 0
      32 - 127    ASCII
      128 - 159   Control set 1
      160 - 255   Right half of ISO-8859-1
    </TD>
    </TR>
</TABLE>


<P class="column8">
        If support for Mule does not exist, these are the only valid
        character values. When Mule support exists, the values
        assigned to other characters may vary depending on the
        particular version of XEmacs, the order in which character sets
        were loaded, etc., and you should not depend on them.


<P class="column7"><EM><STRONG>
       17.6.3 Char-to-int: (ch) XEmacs20</STRONG></EM>



<P class="column8">
        &ndash; a built-in function. Convert a character into an equivalent
        integer. The resulting integer will always be non-negative. The
        integers in the range 0 - 255 map to characters as follows:

<P>
<TABLE  class="shade-normal"
        width="94%"
        border="0"
        cellpadding="10"
        cellspacing="0"
        >
    <TR>
    <TD class="shade-normal-attrib" valign="top">
    <PRE>      0 - 31          Control set 0
      32 - 127        ASCII
      128 - 159       Control set 1
      160 - 255       Right half of ISO-8859-1
    </TD>
    </TR>
</TABLE>


<P class="column8">
        If support for Mule does not exist, these are the only valid
        character values. When Mule support exists, the values assigned to
        other characters may vary depending on the particular version of
        XEmacs, the order in which character sets were loaded, etc., and
        you should not depend on them.


<P class="column7"><EM><STRONG>
       17.6.4 Int-to-char: (integer) XEmacs20</STRONG></EM>



<P class="column8">
        &ndash; a built-in function. Convert an integer into the equivalent
        character. Not all integers correspond to valid characters; use
        <SAMP class="word">char-int-p</SAMP> to determine whether this is the case. If the integer
        cannot be converted, nil is returned.


<P class="column7"><EM><STRONG>
       17.6.5 Char-int-p: (object) XEmacs20</STRONG></EM>



<P class="column8">
        &ndash; a built-in function. t if OBJECT is an integer that can be
        converted into a character. See <SAMP class="word">char-to-int</SAMP>.


<P class="column7"><EM><STRONG>
       17.6.6 Char-equal function (c1 c2 &amp;optional buffer) XEmacs20.0</STRONG></EM>



<P class="column8">
        &ndash; a built-in function. Return t if two characters match,
        optionally ignoring case. Both arguments must be characters
        (i.e. NOT integers). Case is ignored if <SAMP class="word">case-fold-search</SAMP> is
        non-nil in BUFFER. If BUFFER is nil, the current buffer is
        assumed.


<P class="column7"><EM><STRONG>
       17.6.7 Char= (c1 c2 &amp;optional buffer) XEmacs20.1</STRONG></EM>



<P class="column8">
        &ndash; a built-in function. Return t if two characters match, case is
        significant. Both arguments must be characters (i.e. NOT
        integers). The optional buffer argument is for symmetry and is
        ignored.



<!--    ......................................................................
    DOCUMENT END BLOCK
    ......................................................................
-->

</BLOCKQUOTE>
<HR>
<EM    class="footer">
<P>
Copyright &copy; 2004 by Jari Aalto. This material may be
distributed only subject to the terms and conditions set forth
in the Open Publication License, v1.0 or later (the latest
version is presently available at
http://www.opencontent.org/). Distribution of the work
or derivative of the work for commercial purposes in any
form is prohibited unless prior permission is obtained from
the copyright holder. (VI.B LICENSE OPTIONS)
</P>
<P>
This file has been automatically generated from plain text file
with Perl script <STRONG>t2html.pl v2004.0428</STRONG><BR>
Document author: Jari Aalto<BR>
Url: <A HREF="http://tiny-tools.sourceforge.net">http://tiny-tools.sourceforge.net</A><BR>
Last updated: 2004-08-19 12:06<BR>
</EM    class="footer">
</BODY>
</HTML>
